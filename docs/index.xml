<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>大大很二</title>
        <link>https://russellgao.cn/</link>
        <description>用技术改变世界</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>1060745366@qq.com (高维宗(russellgao))</managingEditor>
            <webMaster>1060745366@qq.com (高维宗(russellgao))</webMaster>
            <atom:link href="https://russellgao.cn/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>消息队列原理之rabbitmq</title>
    <link>https://russellgao.cn/mq-rabbitmq/</link>
    <pubDate>Wed, 16 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/mq-rabbitmq/</guid>
    <description><![CDATA[导读  谈起消息队列，我们的脑海可能会不由自主的冒出这么几个关键词，解耦、异步化、消峰、广播等，消息队列的种类也很多，如 rabbitmq、rocketmq、activemq、kafka等还有各个云厂商提供的消息队列。 它们都有各种的特点和使用场景，所以这个系列的文章主要谈各个消息的原理，目前规划了两篇文章，rabbitmq 和 kafka ，其他的暂时还没有用到，还没有深究。
这篇主要介绍 rabbitmq 的原理和基于 golang 如何使用。]]></description>
</item><item>
    <title>深入浅出的聊聊 cpu 负载与使用率</title>
    <link>https://russellgao.cn/cpu/</link>
    <pubDate>Tue, 15 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/cpu/</guid>
    <description><![CDATA[导读  在定位性能问题时，一个绕不开的话题就是 CPU ，会觉得 CPU 不够用了，或者是瓶颈了，那么怎么来确定是 CPU 的问题呢？衡量 CPU 的指标有两个，CPU 负载(load average) 和 使用率，这两者有什么关系和区别呢？ 这篇文章带大家深层次的了解一下 CPU 。]]></description>
</item><item>
    <title>git 常用命令</title>
    <link>https://russellgao.cn/git-command/</link>
    <pubDate>Mon, 14 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/git-command/</guid>
    <description><![CDATA[导读  这篇文章主要记录了 git 的一些常用命令，后续会持续补充更新。
 常用命令 检出代码 1  git clone url -b git_branch   查看分支 1  git branch -a   创建分支 1  git branch xxx   删除本地分支 1  git branch -d xxxxx   检出分支 1  git checkout git_branch   拉取代码 1  git pull   把修改文件提交到缓冲区 1  git add &lt;filename&gt;   本地提交 1  git commit -m &#34;代码提交信息&#34;   推送代码 1 2  git push origin local_branch:remote_branch 例 : git push origin release/release:release/release   合并代码 1  git merge origin/remote   cherry pick 1  git cherry-pick commit_id   跟踪 1 2  git branch --set-upstream-to=remote_branch local_branch 例 git branch --set-upstream-to=origin/release/release release/release   丢弃本地修改 1 2  git checkout -- file 例 git checkout -- test.]]></description>
</item><item>
    <title>docker 原理之本地存储</title>
    <link>https://russellgao.cn/docker-local-storage/</link>
    <pubDate>Wed, 09 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/docker-local-storage/</guid>
    <description><![CDATA[导读  在前面的文章docker 原理之存储驱动中简单的介绍了 Docker 的存储驱动，这篇文章接着讲存储，目前的 docker 版本中默认的是 overlay2 ，所以这篇文章就以 overlay2 为例带大家看看，在我们执行 docker build ，docker pull，docker run 等命令时本地存储有何变化。]]></description>
</item><item>
    <title>Python 中的迭代器与生成器</title>
    <link>https://russellgao.cn/python-iter/</link>
    <pubDate>Mon, 07 Dec 2020 18:32:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/python-iter/</guid>
    <description><![CDATA[导读  这篇文章主要介绍了 python 当中的迭代器与生成器，在涉及到大数量的场景应该考虑使用迭代器与生成器。
 可迭代对象 如果一个对象实现了 __iter__ 方法，那么我们就称它是一个可迭代对象。如果没有实现 __iter__ 而实现了 __getitem__ 方法，并且其参数是从0开始索引的，这种对象也是可迭代的，比如说序列。]]></description>
</item><item>
    <title>docker 原理之存储驱动</title>
    <link>https://russellgao.cn/docker-storage/</link>
    <pubDate>Sat, 05 Dec 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/docker-storage/</guid>
    <description><![CDATA[导读  提起 docker 大家应该耳熟能详，如使用 docker 所带来的持续集成、版本控制、可移植性、隔离性、安全性等诸多好处。docker 的使用也很方便，但是其内部原理是什么样的？都有哪些组件？之间是如何相互协作的呢？这是 docker 系列文章，每篇讲解一个知识点，可以更好的消化。 这篇谈谈 docker 的存储驱动。受限作者水平，如有不对之处，欢迎批评之处。]]></description>
</item><item>
    <title>OSCHINA 搬迁申明</title>
    <link>https://russellgao.cn/oschina-blog/</link>
    <pubDate>Mon, 30 Nov 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/oschina-blog/</guid>
    <description><![CDATA[导读  我的博客即将同步至 OSCHINA 社区，这是我的 OSCHINA ID：russellgao，邀请大家一同入驻：https://www.oschina.net/sharing-plan/apply
 ]]></description>
</item><item>
    <title>harbor gc 时遇到的坑</title>
    <link>https://russellgao.cn/harbor-gc/</link>
    <pubDate>Sun, 29 Nov 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/harbor-gc/</guid>
    <description><![CDATA[导读  Harbor 是为企业用户设计的容器镜像仓库开源项目，包括了权限管理(RBAC)、LDAP、审计、安全漏洞扫描、镜像验真、管理界面、自我注册、HA 等企业必需的功能，同时针对中国用户的特点，设计镜像复制和中文支持等功能。
在使用的过程会有 GC 的需求，可以想象下这几种场景:
 在 CI 的过程，同一个版本（SNAPSHOT/latest）编译很多次，只有最后一次产生的才有 tag ，那么之前的产生 blob 去哪了，或者还有用吗 ？ 镜像的生命周期已经结束，需要从仓库中删除，应该怎么操作？要知道在 Harbor 界面上删除只是标记删除，并不会释放存储空间。  Harbor / Docker 官方已经提供比较完善的 GC 方案，可以解决 80% 的问题，但是 GC 的过程中还可能出现一些奇怪的现象，本文主要记录在 Harbor GC 过程中踩过的坑。]]></description>
</item><item>
    <title>细谈 Golang 中那些设计优美的细节-GMP</title>
    <link>https://russellgao.cn/golang-gmp/</link>
    <pubDate>Fri, 27 Nov 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/golang-gmp/</guid>
    <description><![CDATA[导读  这是 Golang 系列第二篇，这篇主要谈谈 Golang 的调度模型-GMP，我们知道 Golang 在并发方面有绝对优势，现在就让我们来揭开 它神秘的面纱。]]></description>
</item><item>
    <title>如何利用 golang 操纵 oracle</title>
    <link>https://russellgao.cn/oracle-golang/</link>
    <pubDate>Wed, 25 Nov 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://russellgao.cn/oracle-golang/</guid>
    <description><![CDATA[导读 这篇文章主要介绍如何利用 golang 操作 oracle 数据库，包括基本的增删改查，本地 oracle 环境搭建，以及如何在 docker 中运行。 oracle client 镜像构建并不容易，花了很长时间去踩坑，文中提供了已经构建好的基础镜像，可以直接使用，这里贡献给大家。]]></description>
</item></channel>
</rss>
