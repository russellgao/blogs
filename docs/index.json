[{"categories":null,"content":"投稿到 servicemesh 社区的文章","date":"2020-11-10","objectID":"/opensrouce/elk/","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"ELK 这篇文档是由我投稿的云原生社区的文章，节选自 istio-handbook，如果有兴趣可以参考这本书。 ELK 指的是由 Elasticsearch + Logstash + Kibana 组成的日志采集、存储、展示为一体的日志解决方案，简称 “ELK Stack”。ELK Stack 还包含 Beats（如Filebeat、Metricbeat、Heartbeat等）、Kafka等成员，是目前主流的一种日志解决方案。 Elasticsearch 是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。 Logstash 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。Logstash 比较耗资源，在实践中我们一般用作实时解析和转换数据。Logstash 采用可插拔框架，拥有 200 多个插件。您可以将不同的输入选择、过滤器和输出选择混合搭配、精心安排，让它们在管道中和谐地运行。 Kibana 是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。 Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。用来做缓冲，当日志量比较大的时候可以缓解后端 Elasticsearch 的压力。 Beats 是数据采集的得力工具。Beats家族成员包括如下： Filebeat：用于日志文件采集，内置了多种模块（Apache、Cisco ASA、Microsoft Azure、NGINX、MySQL 等等）。 Metricbeat： 用于指标采集。 Packetbeat：用于网络数据采集。 Winlogbeat：用于Windows 事件采集。 Auditbeat：用于审计日志采集。 Heartbeat：用于运行时间采集。 其中 Filebeat 被经常用来收集 Node 或者 Pod 中的日志。 Beats 用于收集客户端的日志，发送给缓存队列如Kafka，目的是为了解耦数据收集与解析入库的过程，同时提高了可扩展性，使日志系统有峰值处理能力，不会因为突发的访问压力造成日志系统奔溃。缓存队列可选的还有 Redis，由于 Redis 是内存型，很容易写满，生产环境建议用 kafka。Logstash 从 缓存队列中消费日志解析处理之后写到 Elasticsearch，通过 Kibana 展示给最终用户。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:0:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"采集方案 Filebeat 有两种部署模式，一是通过 DaemonSet 方式部署，二是通过 Sidecar 方式部署，Filebeat 采集后发送到 Kafka ，再由 Logstash 从 Kafka 中消费写到 Elasticsearch。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:1:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"DaemonSet 方式部署 开启 Envoy 的访问日志输出到 stdout ，以 DaemonSet 的方式在每一台集群节点部署 Filebeat ，并将日志目录挂载至 Filebeat Pod，实现对 Envoy 访问日志的采集。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:1:1","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"Sidecar 方式部署 Filebeat 和 Envoy 部署在同一个 Pod 内，共享日志数据卷， Envoy 写，Filebeat 读，实现对 Envoy 访问日志的采集。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:1:2","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"部署 ELK 有了以上的基础，我们开始部署 ELK Stack ","date":"2020-11-10","objectID":"/opensrouce/elk/:2:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"部署 Kafka 首先，创建一个新的 namespace 用于部署 ELK Stack： # Logging Namespace. All below are a part of this namespace. apiVersion: v1 kind: Namespace metadata: name: logging 接下来，部署 Kafka 服务。 Kafka 通过 Zookeeper 管理集群配置，所以在部署 Kafka 需要先部署 Zookeeper。 Zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务。 Kafka 与 Zookeeper 都是有状态服务，部署时需要选择 StatefulSet 。 部署 Zookeeper Service apiVersion:v1kind:Servicemetadata:name:zookeeper-clusternamespace:loggingspec:selector:app:zookeeper-clusterports:- name:httpport:2181targetPort:2181type:ClusterIP Zookeeper 在集群内使用，供 Kafka 使用，创建类型为 ClusterIP 的 Service 。 Zookeeper 的默认端口是2181。 部署 Zookeeper ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:zookeeper-confignamespace:loggingdata:ZOO_CONF_DIR:/confZOO_PORT:\"2181\" Zookeeper 配置文件中的 key 都可以 以 ZOO_ 加大写的方式设置到环境变量中，使之生效。 这里仅列举部分配置。 部署 Zookeeper StatefulSet apiVersion:apps/v1kind:StatefulSetmetadata:name:zookeepernamespace:loggingspec:serviceName:zookeeper-clusterreplicas:1updateStrategy:type:RollingUpdateselector:matchLabels:app:zookeeper-clustertemplate:metadata:labels:app:zookeeper-clusterannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:zookeeperresources:requests:cpu:10mmemory:100Milimits:memory:200Miimage:zookeeperimagePullPolicy:IfNotPresentenvFrom:- configMapRef:name:zookeeper-configreadinessProbe:tcpSocket:port:2181initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:2181initialDelaySeconds:15periodSeconds:20ports:- containerPort:2181name:zk-client sidecar.istio.io/inject=false 标识此服务无需 sidecar 注入。 部署 Kafka Service apiVersion:v1kind:Servicemetadata:name:bootstrap-kafkanamespace:loggingspec:clusterIP:Noneports:- port:9092selector:app:kafka---apiVersion:v1kind:Servicemetadata:name:kafka-clusternamespace:loggingspec:ports:- name:httptargetPort:9092port:9092selector:app:kafkatype:ClusterIP 部署两个 Service 。 bootstrap-kafka 为后续部署 Kafka Statefulset 使用。 kafka-cluster 为 Kafka 的访问入口，在生产中使用可以用其他的 Service 类型。 kafka 的默认端口是9092 部署 Kafka ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:kafka-confignamespace:loggingdata:KAFKA_ADVERTISED_LISTENERS:\"PLAINTEXT://kafka-cluster:9092\"KAFKA_LISTENERS:\"PLAINTEXT://0.0.0.0:9092\"KAFKA_ZOOKEEPER_CONNECT:\"zookeeper-cluster:2181\"KAFKA_LOG_RETENTION_HOURS:\"48\"KAFKA_NUM_PARTITIONS:\"30\" Kafka 配置文件（server.properties）中的 key 都可以 以 KAFKA_ 加大写的方式设置到环境变量中，使之生效。 KAFKA_ADVERTISED_LISTENERS 为 Kafka 监听的服务地址。 KAFKA_ZOOKEEPER_CONNECT 为前面部署的 Zookeeper 的服务地址。 KAFKA_LOG_RETENTION_HOURS 为 Kafka 数据保留的时间，超过这个时间将会被清理，可以根据实际情况进行调整。 KAFKA_NUM_PARTITIONS 为创建 Kafka topic 时的默认分片数，设置大一些可以增加 Kafka 的吞吐量。 这里仅列举部分配置。 部署 Kafka StatefulSet apiVersion:apps/v1kind:StatefulSetmetadata:name:kafkanamespace:loggingspec:selector:matchLabels:app:kafkaserviceName:bootstrap-kafkareplicas:1template:metadata:labels:app:kafkaannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:kafka-brokerimage:russellgao/kafka:2.12-2.0.1ports:- name:insidecontainerPort:9092resources:requests:cpu:0.1memory:1024Milimits:memory:3069MireadinessProbe:tcpSocket:port:9092timeoutSeconds:1initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:9092timeoutSeconds:1initialDelaySeconds:15periodSeconds:20envFrom:- configMapRef:name:kafka-config kafka 对磁盘的 IO 要求较高，可以选择固态硬盘或者经过IO优化的磁盘，否则可能会成为日志系统的瓶颈。 请注意，本次实践没有把数据卷映射出来，在生产实践中使用 volumeClaimTemplates 来为 Pod 提供持久化存储。resources 可以根据实际情况调整。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:2:1","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"部署 Logstash Logstash 是一个无状态服务，通过 Deployment 进行部署。 部署 Logstash ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:logstash-confnamespace:loggingdata:logstash.conf:| input {http{host=\u003e\"0.0.0.0\"# default: 0.0.0.0port =\u003e 8080 # default:8080user=\u003e\"logstash\"password=\u003e\"aoDJ0JVgkfNPjarn\"response_headers=\u003e{\"Content-Type\"=\u003e\"text/plain\"\"Access-Control-Allow-Origin\"=\u003e\"*\"\"Access-Control-Allow-Methods\"=\u003e\"GET, POST, DELETE, PUT\"\"Access-Control-Allow-Headers\"=\u003e\"authorization, content-type\"\"Access-Control-Allow-Credentials\"=\u003etrue}}kafka{topics=\u003e\"istio\"bootstrap_servers=\u003e\"kafka-cluster:9092\"auto_offset_reset=\u003e\"earliest\"group_id=\u003e\"istio_kafka_gr\"consumer_threads=\u003e3codec=\u003e\"json\"}}filter{grok{match=\u003e{\"message\"=\u003e\"(?m)\\[%{TIMESTAMP_ISO8601:timestamp}\\] \"%{NOTSPACE:method}%{NOTSPACE:path}%{NOTSPACE:protocol}\" %{NUMBER:response_code:int} %{NOTSPACE:response_flags} \"%{NOTSPACE:istio_policy_status}\" \"%{NOTSPACE:upstream_transport_failure_reason}\" %{NUMBER:bytes_received:int} %{NUMBER:bytes_sent:int} %{NUMBER:duration:int} %{NUMBER:upstream_service_time:int} \"%{NOTSPACE:x_forwarded_for}\" \"%{NOTSPACE:user_agent}\" \"%{NOTSPACE:request_id}\" \"%{NOTSPACE:authority}\" \"%{NOTSPACE:upstream_host}\" %{NOTSPACE:upstream_cluster} %{NOTSPACE:upstream_local_address} %{NOTSPACE:downstream_local_address} %{NOTSPACE:downstream_remote_address} %{NOTSPACE:requested_server_name} %{NOTSPACE:route_name}\"}remove_field=\u003e[\"message\"]}date{match=\u003e[\"timestamp\",\"yyyy-MM-ddTHH:mm:ss.SSSZ\"]timezone=\u003e\"Asia/Shanghai\"}ruby{code=\u003e\"event.set('[@metadata][index_day]',(event.get('@timestamp').time.localtime + 8*60*60 ).strftime('%Y.%m.%d'))\"}}output{if\"_grokparsefailure\"notin[tags]{elasticsearch{user=\u003e\"elastic\"password=\u003e\"elastic\"hosts=\u003e[\"elasticsearch.com:9200\"]index=\u003e\"istio-%{[@metadata][index_day]}\"}}} Logstash 配置由3部分组成： input Logstash input 支持非常多的数据源，如 File、Elasticsearch、Beats、Redis、Kafka、Http等。 Http input 用于Logstash 的健康检查，也可通过 http 接口将日志直接发送到 Logstash，主要用于移动端的场景。 Kafka input 用于收集日志，一个input只能从一个 Topic 中读取数据，需要和后续的 Filebeat output 对应。 filter Logstash filter 支持非常多的插件，可以对数据进行解析、加工、转换，如 grok、date、ruby、json、drop等。 grok 用于对日志进行解析。 date 用于把 timestamp 转化成 elasticsearch 中的 @timestamp 字段，可以指定时区。 ruby 插件支持执行 ruby 代码，可以进行复杂逻辑的处理，此处的用法是 @timestamp 字段的时间加8小时，解决自动生成的索引时差问题。 output Logstash output 支持非常多的数据源，如 elasticsearch、cvs、jdbc 等。 此处是把 grok 解析成功的日志写到 elasticsearch 。 部署 Logstash Deployment apiVersion:apps/v1beta2kind:Deploymentmetadata:name:logstashnamespace:loggingspec:replicas:2selector:matchLabels:app:logstashtemplate:metadata:labels:app:logstashannotations:sidecar.istio.io/inject:\"false\"spec:volumes:- name:configconfigMap:name:logstash-confhostname:logstashcontainers:- name:logstashimage:logstash:7.2.0args:[\"-f\",\"/usr/share/logstash/pipeline/logstash.conf\",]imagePullPolicy:IfNotPresentvolumeMounts:- name:configmountPath:\"/usr/share/logstash/pipeline/logstash.conf\"readOnly:truesubPath:logstash.confresources:requests:cpu:0.5memory:1024Milimits:cpu:1.5memory:3072MireadinessProbe:tcpSocket:port:8080initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:8080initialDelaySeconds:15periodSeconds:20 Logstash 不需要对外发布服务，即不需要创建 Service，从 Kafka 中消费日志，处理完成之后写到 Elasticsearch 。 Logstash 只需要把配置文件挂载进去，无需挂载其他目录，排查错误时可通过 Logstash Console Log 进行查看。 部署 Logstash HorizontalPodAutoscaler apiVersion:autoscaling/v2beta1kind:HorizontalPodAutoscalermetadata:name:logstashnamespace:loggingspec:scaleTargetRef:apiVersion:apps/v1beta2kind:Deploymentname:logstashminReplicas:2maxReplicas:10metrics:- type:Resourceresource:name:cputargetAverageUtilization:80 Logstash 比较消费 CPU ，可以部署 HPA，可以根据日志量动态的扩所容。 Logstash 的压力对 CPU 比较敏感，可以只根据 CPU 这一个指标进行 HPA。 Logstash 的配置文件支持if/else条件判断，通过这种方式，一个 Logstash 集群可以支持比较多的日志格式。另外 Logstash 的 grok 语法相对复杂，可以使用 Kibana Dev Tools 工具进行调试，如下图： ","date":"2020-11-10","objectID":"/opensrouce/elk/:2:2","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"部署 Filebeat 这里仅给出 Filebeat DaemonSet 的部署过程。 部署 Filebeat ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:filebeat-confnamespace:loggingdata:filebeat.yml:| filebeat:inputs:- paths:- /var/log- /var/lib/docker/containersignore_older:1hforce_close_files:true#强制filebeat在文件名改变时，关闭文件，会有丢失日志的风险close_older:1mfields_under_root:trueoutput:kafka:enabled:truehosts:[\"kafka-cluster:9092\"]topic:\"istio\"version:\"2.0.0\"partition.round_robin:reachable_only:falseworker:2max_retries:3bulk_max_size:2048timeout:30sbroker_timeout:10schannel_buffer_size:256keep_alive:60compression:gzipmax_message_bytes:1000000required_acks:1 input.paths 代表 Filebeat 监听的日志路径。 input.ignore_older 代表日志文件的修改时间超过这个之间，将会忽略，这个在 Filebeat 重启时很有效果，解决重复读取日志的问题。 out.kafka.hosts 和之前部署的 Kafka Service 对应。 out.kafka.topic 和之前部署的 Logstash ConfigMap 中的 input 对应。 部署 Filebeat DaemonSet apiVersion:apps/v1kind:DaemonSetmetadata:name:filebeatnamespace:logginglabels:app:filebeatspec:selector:matchLabels:app:filebeattemplate:metadata:labels:app:filebeatannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:filebeatimage:elastic/filebeat:7.2.0imagePullPolicy:IfNotPresentvolumeMounts:- name:configmountPath:\"/usr/share/filebeat/filebeat.yml\"readOnly:truesubPath:filebeat.yml- name:varlogmountPath:/var/log- name:varlibdockercontainersmountPath:/var/lib/docker/containersresources:requests:cpu:0.1memory:200Milimits:cpu:0.3memory:600Mivolumes:- name:varloghostPath:path:/var/log- name:varlibdockercontainershostPath:path:/var/lib/docker/containers- name:configconfigMap:name:filebeat-conf 这里声明了两个 hostPath 类型的数据卷，路径为日志存储的路径。 将宿主机的 /var/log 和 /var/lib/docker/containers 挂载到了 Filebeat Pod 内便于 Filebeat 收集日志。 Filebeat 不需要部署 Service 。 Filebeat 对资源消耗比较少，可忽略对 Node 的资源消耗。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:2:3","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"小结 本节为大家介绍了 ELK 的原理和安装部署，以及如何收集日志。 ","date":"2020-11-10","objectID":"/opensrouce/elk/:3:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"参考 Beats Logstash Zookeeper ","date":"2020-11-10","objectID":"/opensrouce/elk/:4:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/opensrouce/elk/"},{"categories":null,"content":"投稿到 servicemesh 社区的文章","date":"2020-11-10","objectID":"/elk/","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"ELK 这篇文档是由我投稿的云原生社区的文章，节选自 istio-handbook，如果有兴趣可以参考这本书。 ELK 指的是由 Elasticsearch + Logstash + Kibana 组成的日志采集、存储、展示为一体的日志解决方案，简称 “ELK Stack”。ELK Stack 还包含 Beats（如Filebeat、Metricbeat、Heartbeat等）、Kafka等成员，是目前主流的一种日志解决方案。 Elasticsearch 是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。 Logstash 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。Logstash 比较耗资源，在实践中我们一般用作实时解析和转换数据。Logstash 采用可插拔框架，拥有 200 多个插件。您可以将不同的输入选择、过滤器和输出选择混合搭配、精心安排，让它们在管道中和谐地运行。 Kibana 是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。 Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。用来做缓冲，当日志量比较大的时候可以缓解后端 Elasticsearch 的压力。 Beats 是数据采集的得力工具。Beats家族成员包括如下： Filebeat：用于日志文件采集，内置了多种模块（Apache、Cisco ASA、Microsoft Azure、NGINX、MySQL 等等）。 Metricbeat： 用于指标采集。 Packetbeat：用于网络数据采集。 Winlogbeat：用于Windows 事件采集。 Auditbeat：用于审计日志采集。 Heartbeat：用于运行时间采集。 其中 Filebeat 被经常用来收集 Node 或者 Pod 中的日志。 Beats 用于收集客户端的日志，发送给缓存队列如Kafka，目的是为了解耦数据收集与解析入库的过程，同时提高了可扩展性，使日志系统有峰值处理能力，不会因为突发的访问压力造成日志系统奔溃。缓存队列可选的还有 Redis，由于 Redis 是内存型，很容易写满，生产环境建议用 kafka。Logstash 从 缓存队列中消费日志解析处理之后写到 Elasticsearch，通过 Kibana 展示给最终用户。 ","date":"2020-11-10","objectID":"/elk/:0:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"采集方案 Filebeat 有两种部署模式，一是通过 DaemonSet 方式部署，二是通过 Sidecar 方式部署，Filebeat 采集后发送到 Kafka ，再由 Logstash 从 Kafka 中消费写到 Elasticsearch。 ","date":"2020-11-10","objectID":"/elk/:1:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"DaemonSet 方式部署 开启 Envoy 的访问日志输出到 stdout ，以 DaemonSet 的方式在每一台集群节点部署 Filebeat ，并将日志目录挂载至 Filebeat Pod，实现对 Envoy 访问日志的采集。 ","date":"2020-11-10","objectID":"/elk/:1:1","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"Sidecar 方式部署 Filebeat 和 Envoy 部署在同一个 Pod 内，共享日志数据卷， Envoy 写，Filebeat 读，实现对 Envoy 访问日志的采集。 ","date":"2020-11-10","objectID":"/elk/:1:2","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"部署 ELK 有了以上的基础，我们开始部署 ELK Stack ","date":"2020-11-10","objectID":"/elk/:2:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"部署 Kafka 首先，创建一个新的 namespace 用于部署 ELK Stack： # Logging Namespace. All below are a part of this namespace. apiVersion: v1 kind: Namespace metadata: name: logging 接下来，部署 Kafka 服务。 Kafka 通过 Zookeeper 管理集群配置，所以在部署 Kafka 需要先部署 Zookeeper。 Zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务。 Kafka 与 Zookeeper 都是有状态服务，部署时需要选择 StatefulSet 。 部署 Zookeeper Service apiVersion:v1kind:Servicemetadata:name:zookeeper-clusternamespace:loggingspec:selector:app:zookeeper-clusterports:- name:httpport:2181targetPort:2181type:ClusterIP Zookeeper 在集群内使用，供 Kafka 使用，创建类型为 ClusterIP 的 Service 。 Zookeeper 的默认端口是2181。 部署 Zookeeper ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:zookeeper-confignamespace:loggingdata:ZOO_CONF_DIR:/confZOO_PORT:\"2181\" Zookeeper 配置文件中的 key 都可以 以 ZOO_ 加大写的方式设置到环境变量中，使之生效。 这里仅列举部分配置。 部署 Zookeeper StatefulSet apiVersion:apps/v1kind:StatefulSetmetadata:name:zookeepernamespace:loggingspec:serviceName:zookeeper-clusterreplicas:1updateStrategy:type:RollingUpdateselector:matchLabels:app:zookeeper-clustertemplate:metadata:labels:app:zookeeper-clusterannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:zookeeperresources:requests:cpu:10mmemory:100Milimits:memory:200Miimage:zookeeperimagePullPolicy:IfNotPresentenvFrom:- configMapRef:name:zookeeper-configreadinessProbe:tcpSocket:port:2181initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:2181initialDelaySeconds:15periodSeconds:20ports:- containerPort:2181name:zk-client sidecar.istio.io/inject=false 标识此服务无需 sidecar 注入。 部署 Kafka Service apiVersion:v1kind:Servicemetadata:name:bootstrap-kafkanamespace:loggingspec:clusterIP:Noneports:- port:9092selector:app:kafka---apiVersion:v1kind:Servicemetadata:name:kafka-clusternamespace:loggingspec:ports:- name:httptargetPort:9092port:9092selector:app:kafkatype:ClusterIP 部署两个 Service 。 bootstrap-kafka 为后续部署 Kafka Statefulset 使用。 kafka-cluster 为 Kafka 的访问入口，在生产中使用可以用其他的 Service 类型。 kafka 的默认端口是9092 部署 Kafka ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:kafka-confignamespace:loggingdata:KAFKA_ADVERTISED_LISTENERS:\"PLAINTEXT://kafka-cluster:9092\"KAFKA_LISTENERS:\"PLAINTEXT://0.0.0.0:9092\"KAFKA_ZOOKEEPER_CONNECT:\"zookeeper-cluster:2181\"KAFKA_LOG_RETENTION_HOURS:\"48\"KAFKA_NUM_PARTITIONS:\"30\" Kafka 配置文件（server.properties）中的 key 都可以 以 KAFKA_ 加大写的方式设置到环境变量中，使之生效。 KAFKA_ADVERTISED_LISTENERS 为 Kafka 监听的服务地址。 KAFKA_ZOOKEEPER_CONNECT 为前面部署的 Zookeeper 的服务地址。 KAFKA_LOG_RETENTION_HOURS 为 Kafka 数据保留的时间，超过这个时间将会被清理，可以根据实际情况进行调整。 KAFKA_NUM_PARTITIONS 为创建 Kafka topic 时的默认分片数，设置大一些可以增加 Kafka 的吞吐量。 这里仅列举部分配置。 部署 Kafka StatefulSet apiVersion:apps/v1kind:StatefulSetmetadata:name:kafkanamespace:loggingspec:selector:matchLabels:app:kafkaserviceName:bootstrap-kafkareplicas:1template:metadata:labels:app:kafkaannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:kafka-brokerimage:russellgao/kafka:2.12-2.0.1ports:- name:insidecontainerPort:9092resources:requests:cpu:0.1memory:1024Milimits:memory:3069MireadinessProbe:tcpSocket:port:9092timeoutSeconds:1initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:9092timeoutSeconds:1initialDelaySeconds:15periodSeconds:20envFrom:- configMapRef:name:kafka-config kafka 对磁盘的 IO 要求较高，可以选择固态硬盘或者经过IO优化的磁盘，否则可能会成为日志系统的瓶颈。 请注意，本次实践没有把数据卷映射出来，在生产实践中使用 volumeClaimTemplates 来为 Pod 提供持久化存储。resources 可以根据实际情况调整。 ","date":"2020-11-10","objectID":"/elk/:2:1","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"部署 Logstash Logstash 是一个无状态服务，通过 Deployment 进行部署。 部署 Logstash ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:logstash-confnamespace:loggingdata:logstash.conf:| input {http{host=\u003e\"0.0.0.0\"# default: 0.0.0.0port =\u003e 8080 # default:8080user=\u003e\"logstash\"password=\u003e\"aoDJ0JVgkfNPjarn\"response_headers=\u003e{\"Content-Type\"=\u003e\"text/plain\"\"Access-Control-Allow-Origin\"=\u003e\"*\"\"Access-Control-Allow-Methods\"=\u003e\"GET, POST, DELETE, PUT\"\"Access-Control-Allow-Headers\"=\u003e\"authorization, content-type\"\"Access-Control-Allow-Credentials\"=\u003etrue}}kafka{topics=\u003e\"istio\"bootstrap_servers=\u003e\"kafka-cluster:9092\"auto_offset_reset=\u003e\"earliest\"group_id=\u003e\"istio_kafka_gr\"consumer_threads=\u003e3codec=\u003e\"json\"}}filter{grok{match=\u003e{\"message\"=\u003e\"(?m)\\[%{TIMESTAMP_ISO8601:timestamp}\\] \"%{NOTSPACE:method}%{NOTSPACE:path}%{NOTSPACE:protocol}\" %{NUMBER:response_code:int} %{NOTSPACE:response_flags} \"%{NOTSPACE:istio_policy_status}\" \"%{NOTSPACE:upstream_transport_failure_reason}\" %{NUMBER:bytes_received:int} %{NUMBER:bytes_sent:int} %{NUMBER:duration:int} %{NUMBER:upstream_service_time:int} \"%{NOTSPACE:x_forwarded_for}\" \"%{NOTSPACE:user_agent}\" \"%{NOTSPACE:request_id}\" \"%{NOTSPACE:authority}\" \"%{NOTSPACE:upstream_host}\" %{NOTSPACE:upstream_cluster} %{NOTSPACE:upstream_local_address} %{NOTSPACE:downstream_local_address} %{NOTSPACE:downstream_remote_address} %{NOTSPACE:requested_server_name} %{NOTSPACE:route_name}\"}remove_field=\u003e[\"message\"]}date{match=\u003e[\"timestamp\",\"yyyy-MM-ddTHH:mm:ss.SSSZ\"]timezone=\u003e\"Asia/Shanghai\"}ruby{code=\u003e\"event.set('[@metadata][index_day]',(event.get('@timestamp').time.localtime + 8*60*60 ).strftime('%Y.%m.%d'))\"}}output{if\"_grokparsefailure\"notin[tags]{elasticsearch{user=\u003e\"elastic\"password=\u003e\"elastic\"hosts=\u003e[\"elasticsearch.com:9200\"]index=\u003e\"istio-%{[@metadata][index_day]}\"}}} Logstash 配置由3部分组成： input Logstash input 支持非常多的数据源，如 File、Elasticsearch、Beats、Redis、Kafka、Http等。 Http input 用于Logstash 的健康检查，也可通过 http 接口将日志直接发送到 Logstash，主要用于移动端的场景。 Kafka input 用于收集日志，一个input只能从一个 Topic 中读取数据，需要和后续的 Filebeat output 对应。 filter Logstash filter 支持非常多的插件，可以对数据进行解析、加工、转换，如 grok、date、ruby、json、drop等。 grok 用于对日志进行解析。 date 用于把 timestamp 转化成 elasticsearch 中的 @timestamp 字段，可以指定时区。 ruby 插件支持执行 ruby 代码，可以进行复杂逻辑的处理，此处的用法是 @timestamp 字段的时间加8小时，解决自动生成的索引时差问题。 output Logstash output 支持非常多的数据源，如 elasticsearch、cvs、jdbc 等。 此处是把 grok 解析成功的日志写到 elasticsearch 。 部署 Logstash Deployment apiVersion:apps/v1beta2kind:Deploymentmetadata:name:logstashnamespace:loggingspec:replicas:2selector:matchLabels:app:logstashtemplate:metadata:labels:app:logstashannotations:sidecar.istio.io/inject:\"false\"spec:volumes:- name:configconfigMap:name:logstash-confhostname:logstashcontainers:- name:logstashimage:logstash:7.2.0args:[\"-f\",\"/usr/share/logstash/pipeline/logstash.conf\",]imagePullPolicy:IfNotPresentvolumeMounts:- name:configmountPath:\"/usr/share/logstash/pipeline/logstash.conf\"readOnly:truesubPath:logstash.confresources:requests:cpu:0.5memory:1024Milimits:cpu:1.5memory:3072MireadinessProbe:tcpSocket:port:8080initialDelaySeconds:5periodSeconds:10livenessProbe:tcpSocket:port:8080initialDelaySeconds:15periodSeconds:20 Logstash 不需要对外发布服务，即不需要创建 Service，从 Kafka 中消费日志，处理完成之后写到 Elasticsearch 。 Logstash 只需要把配置文件挂载进去，无需挂载其他目录，排查错误时可通过 Logstash Console Log 进行查看。 部署 Logstash HorizontalPodAutoscaler apiVersion:autoscaling/v2beta1kind:HorizontalPodAutoscalermetadata:name:logstashnamespace:loggingspec:scaleTargetRef:apiVersion:apps/v1beta2kind:Deploymentname:logstashminReplicas:2maxReplicas:10metrics:- type:Resourceresource:name:cputargetAverageUtilization:80 Logstash 比较消费 CPU ，可以部署 HPA，可以根据日志量动态的扩所容。 Logstash 的压力对 CPU 比较敏感，可以只根据 CPU 这一个指标进行 HPA。 Logstash 的配置文件支持if/else条件判断，通过这种方式，一个 Logstash 集群可以支持比较多的日志格式。另外 Logstash 的 grok 语法相对复杂，可以使用 Kibana Dev Tools 工具进行调试，如下图： ","date":"2020-11-10","objectID":"/elk/:2:2","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"部署 Filebeat 这里仅给出 Filebeat DaemonSet 的部署过程。 部署 Filebeat ConfigMap apiVersion:v1kind:ConfigMapmetadata:name:filebeat-confnamespace:loggingdata:filebeat.yml:| filebeat:inputs:- paths:- /var/log- /var/lib/docker/containersignore_older:1hforce_close_files:true#强制filebeat在文件名改变时，关闭文件，会有丢失日志的风险close_older:1mfields_under_root:trueoutput:kafka:enabled:truehosts:[\"kafka-cluster:9092\"]topic:\"istio\"version:\"2.0.0\"partition.round_robin:reachable_only:falseworker:2max_retries:3bulk_max_size:2048timeout:30sbroker_timeout:10schannel_buffer_size:256keep_alive:60compression:gzipmax_message_bytes:1000000required_acks:1 input.paths 代表 Filebeat 监听的日志路径。 input.ignore_older 代表日志文件的修改时间超过这个之间，将会忽略，这个在 Filebeat 重启时很有效果，解决重复读取日志的问题。 out.kafka.hosts 和之前部署的 Kafka Service 对应。 out.kafka.topic 和之前部署的 Logstash ConfigMap 中的 input 对应。 部署 Filebeat DaemonSet apiVersion:apps/v1kind:DaemonSetmetadata:name:filebeatnamespace:logginglabels:app:filebeatspec:selector:matchLabels:app:filebeattemplate:metadata:labels:app:filebeatannotations:sidecar.istio.io/inject:\"false\"spec:containers:- name:filebeatimage:elastic/filebeat:7.2.0imagePullPolicy:IfNotPresentvolumeMounts:- name:configmountPath:\"/usr/share/filebeat/filebeat.yml\"readOnly:truesubPath:filebeat.yml- name:varlogmountPath:/var/log- name:varlibdockercontainersmountPath:/var/lib/docker/containersresources:requests:cpu:0.1memory:200Milimits:cpu:0.3memory:600Mivolumes:- name:varloghostPath:path:/var/log- name:varlibdockercontainershostPath:path:/var/lib/docker/containers- name:configconfigMap:name:filebeat-conf 这里声明了两个 hostPath 类型的数据卷，路径为日志存储的路径。 将宿主机的 /var/log 和 /var/lib/docker/containers 挂载到了 Filebeat Pod 内便于 Filebeat 收集日志。 Filebeat 不需要部署 Service 。 Filebeat 对资源消耗比较少，可忽略对 Node 的资源消耗。 ","date":"2020-11-10","objectID":"/elk/:2:3","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"小结 本节为大家介绍了 ELK 的原理和安装部署，以及如何收集日志。 ","date":"2020-11-10","objectID":"/elk/:3:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"参考 Beats Logstash Zookeeper ","date":"2020-11-10","objectID":"/elk/:4:0","tags":["kubernetes","istio"],"title":"istio中的ELK实践","uri":"/elk/"},{"categories":null,"content":"Hugo, the world's fastest framework for building websites","date":"2020-11-08","objectID":"/about/","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"简介 高维宗（russellgao），现就职于上海海鼎信息工程股份有限公司，担任运维开发经理。 ","date":"2020-11-08","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"关注领域 专注于devops，aiops，golong，python，kubernetes，servicemesh，云原生，算法等领域，热衷于参与开源软件和开源社区。 ","date":"2020-11-08","objectID":"/about/:2:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"个人公众号 ","date":"2020-11-08","objectID":"/about/:3:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"投稿 如果有好的文章需要分享也可以投稿给作者哟！ ","date":"2020-11-08","objectID":"/about/:4:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"投稿指南 文章须为原创的技术文章 须包含作者的姓名，公司头衔和简要介绍 须通过在 github 提交 PR 的方式提供 ","date":"2020-11-08","objectID":"/about/:4:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Hugo, the world's fastest framework for building websites","date":"2020-11-08","objectID":"/golang/defer/","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"背景 在学习和使用 Go 的过程中发现，Go 在语言层面的设计有很多有趣的地方，所以准备用一个系列来细数这些有趣的地方。写这个系列一是为了加深自己的理解，二是愿意分享，分享 Go 中有趣的设计细节。每篇都会通过一个例子讲述一个细节，感兴趣的话可以关注一下哟！ ","date":"2020-11-08","objectID":"/golang/defer/:1:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"Go 介绍 Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。 Go 是由这3位大佬从2007年9月开始设计Go，2009年正式推出，到目前为止已经发了15个大版本，最新版为1.15.4。Go 现在广泛应用于云原生、中间件、还有各个业务平台，如 docker、kubernetes、etcd等都是Go语言编写。所以还是很有必要了解一下哟！ 下面简单说说Go的优缺点，俗话说：一万个人眼中有一万个哈姆雷特，所以优缺点都是相对而言，就谈谈自己使用过程中的感受，具体的优缺点会在后面的系列文章中一一提到，这里是抛砖引玉。 ","date":"2020-11-08","objectID":"/golang/defer/:2:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"Go 优点 语言层面支持并发：一个 go 关键字即可实现并发，其他编程语言依赖于库实现并发，这是有本质的区别 高性能 编译完之后生成二进制文件，可免去环境依赖 defer 机制 内置runtime 内嵌C支持，Go里面也可以直接包含C代码，利用现有的丰富的C库 跨平台编译 。。。 ","date":"2020-11-08","objectID":"/golang/defer/:3:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"Go 缺点 包管理 。。。 ","date":"2020-11-08","objectID":"/golang/defer/:4:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"defer 说起 Go 语言的最强大的地方，不得不说 Go 的并发机制和调度原理，但是今天不讲这些高深的理论，先从简单的开始。先思考这么几个问题（可以用自己熟悉的语言思考如何解决）: 对于文件的打开关闭，网络连接的建立断开场景，当打开时候应该何时关闭? 当调用一个函数，希望在函数返回时修改它的值，该如何解决? 先看看defer 的官方定义 ： A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. 意思是说，当包裹defer 的函数返回时或者包裹defer的函数执行到末尾时或者所在的goroutine发生panic时才会执行。 换句话说就是当函数执行完之后或者发生异常时再执行defer语句，就是说在被调函数返回之后，赋值给调用函数之前，还有机会执行其他指令，是不是很神奇。先看一段python 代码 : def f(x,y) : z = x / y z += 1 return z ​ if __name__ == \"__main__\" : result = f(4 /2) 当调用函数f，f返回给z并且赋值给result，在这时间，是没有任何机会执行其他的函数代码的。再看一段go代码: package main func main() { result := f(4, 2) fmt.Println(result) } ​ func f(x, y int) (r int) { r = x / y r += 1 defer func() { r += 2 }() return } 当调用函数f，f返回之后，在赋值之前执行了r +=2 。现在回想一下之前的两个问题，如果有defer 机制，是不是可以很好的解决。如对于第一个问题，在defer 语句中处理文件的关闭，连接的释放等，而不用考虑一些异常情况。 那defer的实现原理是怎样的呢? defer 其实是调用runtime.deferproc 进行实现，在defer 出现的地方，插入了call runtime.deferproc，然后在函数返回之前的地方，插入指令call runtime.deferreturn。 普通函数返回时，汇编代码类似于: add xx SP return 如果包含了defer 语句，汇编代码类似于: call runtime.deferreturn， add xx SP return goroutine的控制结构中，有一张表记录defer，调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用runtime.deferreturn的时候，则会依次从defer表中出栈并执行。 defer 在使用过程中也存在一些坑，看几个例子: 例1: func f() (result int) { defer func() { result++ }() return 10 } 例2: func f() (result int) { t := 10 defer func() { t = t + 1 }() return t } 例3: func f() (result int) { defer func(result int) { result = result + 1 }(result) return 10 } 大家可以先心里默默算一下他们的结果 第一个是11，第二个是10，第三个是10。 defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成: 返回值 = xxx 调用defer函数 空的return 例1 会被改写成: func f() (result int) { result = 10 // return语句不是一条原子调用，return xxx其实是赋值＋ret指令 defer func() { result++ }() return // 空的return指令 } 所以返回值是11 例2 会被改写成: func f() (result int) { t := 10 result = t // 赋值指令 defer func() { t = t + 1 //defer被插入到赋值与返回之间执行，这个例子中返回值 result没被修改过 }() return // 空的return指令 } 所以返回值是10 例3 就留给大家自己改写一下啦，有兴趣可以私我沟通哟！ ","date":"2020-11-08","objectID":"/golang/defer/:5:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"总结 这篇主要做了对Go语言的介绍和优缺点，分析了defer 的用法以及实现原理，最后用例子展示了使用过程中可能会存在的坑。下篇预告: Go 的调度模型，欢迎关注!!! 如果有理解不正确的地方，欢迎指出。 ","date":"2020-11-08","objectID":"/golang/defer/:6:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/golang/defer/"},{"categories":null,"content":"Hugo, the world's fastest framework for building websites","date":"2020-11-08","objectID":"/defer/","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"背景 在学习和使用 Go 的过程中发现，Go 在语言层面的设计有很多有趣的地方，所以准备用一个系列来细数这些有趣的地方。写这个系列一是为了加深自己的理解，二是愿意分享，分享 Go 中有趣的设计细节。每篇都会通过一个例子讲述一个细节，感兴趣的话可以关注一下哟！ ","date":"2020-11-08","objectID":"/defer/:1:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"Go 介绍 Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。 Go 是由这3位大佬从2007年9月开始设计Go，2009年正式推出，到目前为止已经发了15个大版本，最新版为1.15.4。Go 现在广泛应用于云原生、中间件、还有各个业务平台，如 docker、kubernetes、etcd等都是Go语言编写。所以还是很有必要了解一下哟！ 下面简单说说Go的优缺点，俗话说：一万个人眼中有一万个哈姆雷特，所以优缺点都是相对而言，就谈谈自己使用过程中的感受，具体的优缺点会在后面的系列文章中一一提到，这里是抛砖引玉。 ","date":"2020-11-08","objectID":"/defer/:2:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"Go 优点 语言层面支持并发：一个 go 关键字即可实现并发，其他编程语言依赖于库实现并发，这是有本质的区别 高性能 编译完之后生成二进制文件，可免去环境依赖 defer 机制 内置runtime 内嵌C支持，Go里面也可以直接包含C代码，利用现有的丰富的C库 跨平台编译 。。。 ","date":"2020-11-08","objectID":"/defer/:3:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"Go 缺点 包管理 。。。 ","date":"2020-11-08","objectID":"/defer/:4:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"defer 说起 Go 语言的最强大的地方，不得不说 Go 的并发机制和调度原理，但是今天不讲这些高深的理论，先从简单的开始。先思考这么几个问题（可以用自己熟悉的语言思考如何解决）: 对于文件的打开关闭，网络连接的建立断开场景，当打开时候应该何时关闭? 当调用一个函数，希望在函数返回时修改它的值，该如何解决? 先看看defer 的官方定义 ： A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. 意思是说，当包裹defer 的函数返回时或者包裹defer的函数执行到末尾时或者所在的goroutine发生panic时才会执行。 换句话说就是当函数执行完之后或者发生异常时再执行defer语句，就是说在被调函数返回之后，赋值给调用函数之前，还有机会执行其他指令，是不是很神奇。先看一段python 代码 : def f(x,y) : z = x / y z += 1 return z ​ if __name__ == \"__main__\" : result = f(4 /2) 当调用函数f，f返回给z并且赋值给result，在这时间，是没有任何机会执行其他的函数代码的。再看一段go代码: package main func main() { result := f(4, 2) fmt.Println(result) } ​ func f(x, y int) (r int) { r = x / y r += 1 defer func() { r += 2 }() return } 当调用函数f，f返回之后，在赋值之前执行了r +=2 。现在回想一下之前的两个问题，如果有defer 机制，是不是可以很好的解决。如对于第一个问题，在defer 语句中处理文件的关闭，连接的释放等，而不用考虑一些异常情况。 那defer的实现原理是怎样的呢? defer 其实是调用runtime.deferproc 进行实现，在defer 出现的地方，插入了call runtime.deferproc，然后在函数返回之前的地方，插入指令call runtime.deferreturn。 普通函数返回时，汇编代码类似于: add xx SP return 如果包含了defer 语句，汇编代码类似于: call runtime.deferreturn， add xx SP return goroutine的控制结构中，有一张表记录defer，调用runtime.deferproc时会将需要defer的表达式记录在表中，而在调用runtime.deferreturn的时候，则会依次从defer表中出栈并执行。 defer 在使用过程中也存在一些坑，看几个例子: 例1: func f() (result int) { defer func() { result++ }() return 10 } 例2: func f() (result int) { t := 10 defer func() { t = t + 1 }() return t } 例3: func f() (result int) { defer func(result int) { result = result + 1 }(result) return 10 } 大家可以先心里默默算一下他们的结果 第一个是11，第二个是10，第三个是10。 defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成: 返回值 = xxx 调用defer函数 空的return 例1 会被改写成: func f() (result int) { result = 10 // return语句不是一条原子调用，return xxx其实是赋值＋ret指令 defer func() { result++ }() return // 空的return指令 } 所以返回值是11 例2 会被改写成: func f() (result int) { t := 10 result = t // 赋值指令 defer func() { t = t + 1 //defer被插入到赋值与返回之间执行，这个例子中返回值 result没被修改过 }() return // 空的return指令 } 所以返回值是10 例3 就留给大家自己改写一下啦，有兴趣可以私我沟通哟！ ","date":"2020-11-08","objectID":"/defer/:5:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"总结 这篇主要做了对Go语言的介绍和优缺点，分析了defer 的用法以及实现原理，最后用例子展示了使用过程中可能会存在的坑。下篇预告: Go 的调度模型，欢迎关注!!! 如果有理解不正确的地方，欢迎指出。 ","date":"2020-11-08","objectID":"/defer/:6:0","tags":["golang","defer"],"title":"细谈 Golang 中那些设计优美的细节-defer","uri":"/defer/"},{"categories":null,"content":"自己开源的项目","date":"2020-11-08","objectID":"/opensrouce/toolkit/","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"toolkit ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:0:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"作用 用于提供工作效率的工具箱，里面有各种工具，就比如真实工具箱中里面有扳手，各种大小的起子，钳子等 某些场景下确实可以达到事半功倍的效果 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:1:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"安装 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:2:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"源码安装 有 go 语言环境的可以直接用源码进行编译运行 git clone https://github.com/russellgao/toolkit.git cd toolkit make ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:2:1","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"二进制 可以直接在release 页面进行下载对应的操作系统的二进制文件 https://github.com/russellgao/toolkit/releases/ ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:2:2","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"用法 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:3:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"本机运行 可以通过如下命令进行 gwz:toolkit gaoweizong$ tkctl --help tkctl is a toolkit entrypoint,run `tkctl --help` get more information. Usage: tkctl [flags] tkctl [command] Available Commands: help Help about any command replace 文本替换，支持正则替换和非正则替换，类似与linux下的sed，但比sed更好用，而且可以跨平台使用 secret 生成随机密码，支持1～100位长度，可以指定是否包含特殊字符 version tkctl version Flags: -h, --help help for tkctl -v, --version show the version and exit Use \"tkctl [command] --help\" for more information about a command. tkctl 中的子命令会不断更新，某个具体的功能请查看Available Commands:下的帮助文档，如文本替换 tkctl replace --help 文本替换，支持正则替换和非正则替换，类似与linux下的sed，但比sed更好用，而且可以跨平台使用 Usage: tkctl replace [flags] Flags: -d, --dirs string 需要替换的目录, 默认为当前路径 (default \".\") -h, --help help for replace -m, --mode string 替换的模式，支持正则（regexp）和非正则（text）两种模式，默认非正则， (default \"text\") -p, --pattern string 需要替换的pattern [required] -r, --repl string 目标字符串 [required] ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:3:1","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"docker 如果本地有docker环境，也可以不用下载二进制的制品，可以通过docker 环境直接运行 docker run -it --rm russellgao/toolkit:latest tkctl --help # 如果有需要可以把目录挂载进去 docker run -it -v /data:/data --rm russellgao/toolkit:latest tkctl --help ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:3:2","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"适用范围 可以跨平台使用 mac windows linux ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:4:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"开发环境 go 1.14.2 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:5:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"支持的功能 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:6:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"1.0.0 文本正则替换 生成随机密码 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:6:1","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"未来展望 期望可以成为一个完整的工具箱，可以解决日常工作中的繁杂事情。 ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:7:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"项目地址 https://github.com/russellgao/toolkit ","date":"2020-11-08","objectID":"/opensrouce/toolkit/:8:0","tags":["golang","toolkit"],"title":"自己开源的项目 - toolkit","uri":"/opensrouce/toolkit/"},{"categories":null,"content":"如何利用 python 操纵 oracle","date":"2020-07-09","objectID":"/oracle/","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"安装库 pip3 install sqlalchemy pip3 install cx_Oracle ","date":"2020-07-09","objectID":"/oracle/:1:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"安装客户端 oracle 客户端下载页面: https://www.oracle.com/database/technologies/instant-client/downloads.html ","date":"2020-07-09","objectID":"/oracle/:2:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"mac https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html 在上面的页面下载之后执行: # 解压 cd ~ unzip instantclient-basic-macos.x64-19.3.0.0.0dbru.zip # 创建link mkdir ~/lib ln -s ~/instantclient_19_3/libclntsh.dylib ~/lib/ ","date":"2020-07-09","objectID":"/oracle/:2:1","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"linux https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html ","date":"2020-07-09","objectID":"/oracle/:2:2","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"windows https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html ","date":"2020-07-09","objectID":"/oracle/:2:3","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"使用 在上面装好库和oracle client 就可以用python 操作 oracle 了 简单用法参见 : from sqlalchemy import * # 连接oracle engine = create_engine('oracle://username:passwoed@xxxxx', encoding=\"utf8\",echo=True) connection = engine.connect() # table, 会根据表名自动生成Table 对象 meta = MetaData() t = Table(\"abcd\",meta,autoload=True,autoload_with=engine) # 获取列 columns = t.c print(columns) # 查询 # s = select([t]) # s = select([t]).where(t.c.name == \"xxxx\") s = select([t]).where(t.c.code == \"xxxx\") result = connection.execute(s) for row in result : print(row[t.c.gid],row[t.c.code],row[t.c.name],row[t.c.note]) result.close() print(\"end\") ","date":"2020-07-09","objectID":"/oracle/:3:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"报错 如果报如下错误: sqlalchemy.exc.DatabaseError: (cx_Oracle.DatabaseError) DPI-1047: Cannot locate a 64-bit Oracle Client library: \"dlopen(libclntsh.dylib, 1): image not found\". See https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html for help (Background on this error at: http://sqlalche.me/e/13/4xp6) 说明oracle的 client 没有正确安装 如果报错如下: sqlalchemy.exc.DatabaseError: (cx_Oracle.DatabaseError) ORA-01017: invalid username/password; logon denied (Background on this error at: http://sqlalche.me/e/13/4xp6) 说明oracle 的用户密码不正确 ","date":"2020-07-09","objectID":"/oracle/:4:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"参考 https://docs.sqlalchemy.org/en/13/dialects/oracle.html https://www.cnblogs.com/iupoint/p/10932069.html ","date":"2020-07-09","objectID":"/oracle/:5:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/oracle/"},{"categories":null,"content":"如何利用 python 操纵 oracle","date":"2020-07-09","objectID":"/python/oracle/","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"安装库 pip3 install sqlalchemy pip3 install cx_Oracle ","date":"2020-07-09","objectID":"/python/oracle/:1:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"安装客户端 oracle 客户端下载页面: https://www.oracle.com/database/technologies/instant-client/downloads.html ","date":"2020-07-09","objectID":"/python/oracle/:2:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"mac https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html 在上面的页面下载之后执行: # 解压 cd ~ unzip instantclient-basic-macos.x64-19.3.0.0.0dbru.zip # 创建link mkdir ~/lib ln -s ~/instantclient_19_3/libclntsh.dylib ~/lib/ ","date":"2020-07-09","objectID":"/python/oracle/:2:1","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"linux https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html ","date":"2020-07-09","objectID":"/python/oracle/:2:2","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"windows https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html ","date":"2020-07-09","objectID":"/python/oracle/:2:3","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"使用 在上面装好库和oracle client 就可以用python 操作 oracle 了 简单用法参见 : from sqlalchemy import * # 连接oracle engine = create_engine('oracle://username:passwoed@xxxxx', encoding=\"utf8\",echo=True) connection = engine.connect() # table, 会根据表名自动生成Table 对象 meta = MetaData() t = Table(\"abcd\",meta,autoload=True,autoload_with=engine) # 获取列 columns = t.c print(columns) # 查询 # s = select([t]) # s = select([t]).where(t.c.name == \"xxxx\") s = select([t]).where(t.c.code == \"xxxx\") result = connection.execute(s) for row in result : print(row[t.c.gid],row[t.c.code],row[t.c.name],row[t.c.note]) result.close() print(\"end\") ","date":"2020-07-09","objectID":"/python/oracle/:3:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"报错 如果报如下错误: sqlalchemy.exc.DatabaseError: (cx_Oracle.DatabaseError) DPI-1047: Cannot locate a 64-bit Oracle Client library: \"dlopen(libclntsh.dylib, 1): image not found\". See https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html for help (Background on this error at: http://sqlalche.me/e/13/4xp6) 说明oracle的 client 没有正确安装 如果报错如下: sqlalchemy.exc.DatabaseError: (cx_Oracle.DatabaseError) ORA-01017: invalid username/password; logon denied (Background on this error at: http://sqlalche.me/e/13/4xp6) 说明oracle 的用户密码不正确 ","date":"2020-07-09","objectID":"/python/oracle/:4:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"参考 https://docs.sqlalchemy.org/en/13/dialects/oracle.html https://www.cnblogs.com/iupoint/p/10932069.html ","date":"2020-07-09","objectID":"/python/oracle/:5:0","tags":["python","oracle","数据库"],"title":"如何利用 python 操纵 oracle","uri":"/python/oracle/"},{"categories":null,"content":"pod 配置文件说明","date":"2020-06-18","objectID":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Pod的定义文件 apiVersion:v1kind:Podmetadata:name:stringnamaspace:stringlabels:- name:stringannotations:- name:stringspec:containers:- name:string# 使用的镜像image:stringimagePullPolicy:[Always|Never|IfNotPresent]command:[string]args:[string]# 工作目录workingDir:stringvolumeMounts:- name:stringmountPath:stringreadOnly:booleanports:- name:stringcontainerPort:inthostPort:intprotocol:stringenv:- name:stringvalue:stringresources:limits:cpu:stringmemory:stringrequests:cpu:stringmemory:stringlivenessProbe:exec:command:[string]httpGet:path:stringport:inthost:stringscheme:stringhttpHeaders:- name:stringvalue:stringtcpSocket:port:int# 多久之后去检查initialDelaySeconds:number# 健康检查超时时间timeoutSeconds:number# 多长时间检查一次periodSeconds:number# 成功的阀值，检查几次成功才算成功successThreshold:0# 失败的阀值，检查几次失败才算失败failureThreshold:0securityContext:# 详细参见 pod_SecurityContext 章节# securityContext 可以配置pod 或者container 级别runAsUser:1000# 运行的用户runAsGroup:3000# 运行的用户组fsGroup:2000privileged:bool# 是否以privileged 权限运行，即这是这个进程拥有特权allowPrivilegeEscalation:bool# 控制一个进程是否能比其父进程获取更多的权限，如果一个容器以privileged权限运行或具有CAP_SYS_ADMIN权限，则AllowPrivilegeEscalation的值将总是truecapabilities:add:[\"NET_ADMIN\",\"SYS_TIME\",\"...\"]# 给某个特定的进程privileged权限，而不用给root用户所有的privileged权限terminationMessagePath:/dev/termination-log# 容器终止的日志文件terminationMessagePolicy:[File|FallbackToLogsOnError]# 默认为File, 容器终止消息输出到文件restartPolicy:[Always|Never|OnFailure]# 重启策略，默认为 AlwaysnodeSelector:object# 通过label 选取nodednsPolicy:ClusterFirst# pod 的 dns 策略 ,可以配置如下值# Default : 和宿主机的DNS完全一致# ClusterFirst: 把集群的DNS写入到Pod的DNS配置，但是如果设置了HostNetwork=true，就会强制设置为Default# ClusterFirstWithHostNet: 把集群的DNS写入到Pod的DNS配置，不管是否设置HostNetwork# None: 忽略所有的DNS配置，一般来说，设置了None之后会自己手动再设置dnsConfigenableServiceLinks:true# Kubernetes支持两种查找服务的主要模式: 环境变量和DNS, 如果不需要服务环境变量, 将 `enableServiceLinks` 标志设置为 `false` 来禁用此模式terminationGracePeriodSeconds:10# 发出删除pod指令后多久之后真正的删除podserviceAccountName:jenkins# pod 绑定的serviceAccountpriorityClassName:# 给pod 设置优先级，参考 : https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/schedulerName:default-scheduler# 如果不配置则使用kubernetes 默认的default-scheduler，如果这个不满足要求则可以自定义一个scheduler# https://kubernetes.io/zh/docs/tasks/administer-cluster/configure-multiple-schedulers/affinity:# 亲和性设置tolerations:- effect:NoExecutekey:node.kubernetes.io/not-readyoperator:ExiststolerationSeconds:300- effect:NoExecutekey:node.kubernetes.io/unreachableoperator:ExiststolerationSeconds:300# 容忍设置imagePullSecrets:- name:string# 镜像拉取策略hostNetwork:false# 是否使用主机网络，默认为false，如果为true，pod直接用主机网络，在pod中可以看到主机的网络接口volumes:- name:stringemptyDir:{}hostPath:path:stringsecret:secretName:stringitems:- key:stringpath:stringconfigMap:name:stringitems:- key:stringpath:string# 目录挂载 ","date":"2020-06-18","objectID":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:1:0","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"pod 具体的样例 apiVersion:v1kind:Podmetadata:labels:app:elastic-clustername:enode-0spec:containers:- env:- name:ES_JAVA_OPTSvalueFrom:configMapKeyRef:key:ES_JAVA_OPTSname:es-configimage:elasticsearch:6.7.2imagePullPolicy:IfNotPresentlivenessProbe:failureThreshold:3httpGet:path:/_cluster/health?local=trueport:9200scheme:HTTPperiodSeconds:600successThreshold:1timeoutSeconds:1name:elasticsearchports:- containerPort:9200name:es-httpprotocol:TCP- containerPort:9300name:es-transportprotocol:TCPreadinessProbe:failureThreshold:3httpGet:path:/_cluster/health?local=trueport:9200scheme:HTTPinitialDelaySeconds:30periodSeconds:20successThreshold:1timeoutSeconds:1resources:limits:cpu:\"2\"memory:10Girequests:cpu:\"1\"memory:8GisecurityContext:capabilities:add:- IPC_LOCK- SYS_RESOURCEprivileged:truerunAsUser:1000terminationMessagePath:/dev/termination-logterminationMessagePolicy:FilevolumeMounts:- mountPath:/usr/share/elasticsearch/dataname:es-data- mountPath:/usr/share/elasticsearch/logsname:es-logs- mountPath:/usr/share/elasticsearch/config/elasticsearch.ymlname:elasticsearch-configsubPath:elasticsearch.yml- mountPath:/var/run/secrets/kubernetes.io/serviceaccountname:default-token-k4r6freadOnly:truednsPolicy:ClusterFirstenableServiceLinks:truehostname:enode-0initContainers:- command:- sysctl- -w- vm.max_map_count=262144image:busyboximagePullPolicy:IfNotPresentname:init-sysctlresources:{}securityContext:privileged:trueterminationMessagePath:/dev/termination-logterminationMessagePolicy:FilevolumeMounts:- mountPath:/var/run/secrets/kubernetes.io/serviceaccountname:default-token-k4r6freadOnly:truepriority:0restartPolicy:AlwaysschedulerName:default-schedulersecurityContext:fsGroup:1000serviceAccount:defaultserviceAccountName:defaultsubdomain:elasticsearch-clusterterminationGracePeriodSeconds:30tolerations:- effect:NoExecutekey:node.kubernetes.io/not-readyoperator:ExiststolerationSeconds:300- effect:NoExecutekey:node.kubernetes.io/unreachableoperator:ExiststolerationSeconds:300volumes:- name:es-datapersistentVolumeClaim:claimName:es-data-enode-0- name:es-logspersistentVolumeClaim:claimName:es-logs-enode-0- configMap:defaultMode:420items:- key:elasticsearch.ymlpath:elasticsearch.ymlname:es-configname:elasticsearch-config- name:default-token-k4r6fsecret:defaultMode:420secretName:default-token-k4r6f ","date":"2020-06-18","objectID":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:2:0","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/kubernetes/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"pod 配置文件说明","date":"2020-06-18","objectID":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Pod的定义文件 apiVersion:v1kind:Podmetadata:name:stringnamaspace:stringlabels:- name:stringannotations:- name:stringspec:containers:- name:string# 使用的镜像image:stringimagePullPolicy:[Always|Never|IfNotPresent]command:[string]args:[string]# 工作目录workingDir:stringvolumeMounts:- name:stringmountPath:stringreadOnly:booleanports:- name:stringcontainerPort:inthostPort:intprotocol:stringenv:- name:stringvalue:stringresources:limits:cpu:stringmemory:stringrequests:cpu:stringmemory:stringlivenessProbe:exec:command:[string]httpGet:path:stringport:inthost:stringscheme:stringhttpHeaders:- name:stringvalue:stringtcpSocket:port:int# 多久之后去检查initialDelaySeconds:number# 健康检查超时时间timeoutSeconds:number# 多长时间检查一次periodSeconds:number# 成功的阀值，检查几次成功才算成功successThreshold:0# 失败的阀值，检查几次失败才算失败failureThreshold:0securityContext:# 详细参见 pod_SecurityContext 章节# securityContext 可以配置pod 或者container 级别runAsUser:1000# 运行的用户runAsGroup:3000# 运行的用户组fsGroup:2000privileged:bool# 是否以privileged 权限运行，即这是这个进程拥有特权allowPrivilegeEscalation:bool# 控制一个进程是否能比其父进程获取更多的权限，如果一个容器以privileged权限运行或具有CAP_SYS_ADMIN权限，则AllowPrivilegeEscalation的值将总是truecapabilities:add:[\"NET_ADMIN\",\"SYS_TIME\",\"...\"]# 给某个特定的进程privileged权限，而不用给root用户所有的privileged权限terminationMessagePath:/dev/termination-log# 容器终止的日志文件terminationMessagePolicy:[File|FallbackToLogsOnError]# 默认为File, 容器终止消息输出到文件restartPolicy:[Always|Never|OnFailure]# 重启策略，默认为 AlwaysnodeSelector:object# 通过label 选取nodednsPolicy:ClusterFirst# pod 的 dns 策略 ,可以配置如下值# Default : 和宿主机的DNS完全一致# ClusterFirst: 把集群的DNS写入到Pod的DNS配置，但是如果设置了HostNetwork=true，就会强制设置为Default# ClusterFirstWithHostNet: 把集群的DNS写入到Pod的DNS配置，不管是否设置HostNetwork# None: 忽略所有的DNS配置，一般来说，设置了None之后会自己手动再设置dnsConfigenableServiceLinks:true# Kubernetes支持两种查找服务的主要模式: 环境变量和DNS, 如果不需要服务环境变量, 将 `enableServiceLinks` 标志设置为 `false` 来禁用此模式terminationGracePeriodSeconds:10# 发出删除pod指令后多久之后真正的删除podserviceAccountName:jenkins# pod 绑定的serviceAccountpriorityClassName:# 给pod 设置优先级，参考 : https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/schedulerName:default-scheduler# 如果不配置则使用kubernetes 默认的default-scheduler，如果这个不满足要求则可以自定义一个scheduler# https://kubernetes.io/zh/docs/tasks/administer-cluster/configure-multiple-schedulers/affinity:# 亲和性设置tolerations:- effect:NoExecutekey:node.kubernetes.io/not-readyoperator:ExiststolerationSeconds:300- effect:NoExecutekey:node.kubernetes.io/unreachableoperator:ExiststolerationSeconds:300# 容忍设置imagePullSecrets:- name:string# 镜像拉取策略hostNetwork:false# 是否使用主机网络，默认为false，如果为true，pod直接用主机网络，在pod中可以看到主机的网络接口volumes:- name:stringemptyDir:{}hostPath:path:stringsecret:secretName:stringitems:- key:stringpath:stringconfigMap:name:stringitems:- key:stringpath:string# 目录挂载 ","date":"2020-06-18","objectID":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:1:0","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"pod 具体的样例 apiVersion:v1kind:Podmetadata:labels:app:elastic-clustername:enode-0spec:containers:- env:- name:ES_JAVA_OPTSvalueFrom:configMapKeyRef:key:ES_JAVA_OPTSname:es-configimage:elasticsearch:6.7.2imagePullPolicy:IfNotPresentlivenessProbe:failureThreshold:3httpGet:path:/_cluster/health?local=trueport:9200scheme:HTTPperiodSeconds:600successThreshold:1timeoutSeconds:1name:elasticsearchports:- containerPort:9200name:es-httpprotocol:TCP- containerPort:9300name:es-transportprotocol:TCPreadinessProbe:failureThreshold:3httpGet:path:/_cluster/health?local=trueport:9200scheme:HTTPinitialDelaySeconds:30periodSeconds:20successThreshold:1timeoutSeconds:1resources:limits:cpu:\"2\"memory:10Girequests:cpu:\"1\"memory:8GisecurityContext:capabilities:add:- IPC_LOCK- SYS_RESOURCEprivileged:truerunAsUser:1000terminationMessagePath:/dev/termination-logterminationMessagePolicy:FilevolumeMounts:- mountPath:/usr/share/elasticsearch/dataname:es-data- mountPath:/usr/share/elasticsearch/logsname:es-logs- mountPath:/usr/share/elasticsearch/config/elasticsearch.ymlname:elasticsearch-configsubPath:elasticsearch.yml- mountPath:/var/run/secrets/kubernetes.io/serviceaccountname:default-token-k4r6freadOnly:truednsPolicy:ClusterFirstenableServiceLinks:truehostname:enode-0initContainers:- command:- sysctl- -w- vm.max_map_count=262144image:busyboximagePullPolicy:IfNotPresentname:init-sysctlresources:{}securityContext:privileged:trueterminationMessagePath:/dev/termination-logterminationMessagePolicy:FilevolumeMounts:- mountPath:/var/run/secrets/kubernetes.io/serviceaccountname:default-token-k4r6freadOnly:truepriority:0restartPolicy:AlwaysschedulerName:default-schedulersecurityContext:fsGroup:1000serviceAccount:defaultserviceAccountName:defaultsubdomain:elasticsearch-clusterterminationGracePeriodSeconds:30tolerations:- effect:NoExecutekey:node.kubernetes.io/not-readyoperator:ExiststolerationSeconds:300- effect:NoExecutekey:node.kubernetes.io/unreachableoperator:ExiststolerationSeconds:300volumes:- name:es-datapersistentVolumeClaim:claimName:es-data-enode-0- name:es-logspersistentVolumeClaim:claimName:es-logs-enode-0- configMap:defaultMode:420items:- key:elasticsearch.ymlpath:elasticsearch.ymlname:es-configname:elasticsearch-config- name:default-token-k4r6fsecret:defaultMode:420secretName:default-token-k4r6f ","date":"2020-06-18","objectID":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/:2:0","tags":["kubernetes","pod"],"title":"pod 配置文件说明","uri":"/pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"位运算合集","date":"2020-05-30","objectID":"/argorithm/bit/","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位运算 计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。 ","date":"2020-05-30","objectID":"/argorithm/bit/:0:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作符 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"\u0026 与运算 \u0026 与运算 两个位都是 1 时，结果才为 1，否则为 0，如 1 0 0 1 1 \u0026 1 1 0 0 1 ------------------------------ 1 0 0 0 1 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如 1 0 0 1 1 | 1 1 0 0 1 ------------------------------ 1 1 0 1 1 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"^ 异或运算 两个位相同则为 0，不同则为 1，如 1 0 0 1 1 ^ 1 1 0 0 1 ----------------------------- 0 1 0 1 0 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"~ 取反运算 0 则变为 1，1 则变为 0，如 ~ 1 0 0 1 1 ----------------------------- 0 1 1 0 0 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"« 左移运算 向左进行移位操作，高位丢弃，低位补 0,如 int a = 8; a \u003c\u003c 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0100 0000 左移n为的值即为当前值*2^n, 如: a = 8 b = a\u003c\u003c3 # 64 c = a * (2 ** 3) # 64 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"»右移运算 向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如 unsigned int a = 8; a \u003e\u003e 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0000 0001 ​ int a = -8; a \u003e\u003e 3; 移位前：1111 1111 1111 1111 1111 1111 1111 1000 移位前：1111 1111 1111 1111 1111 1111 1111 1111 ","date":"2020-05-30","objectID":"/argorithm/bit/:1:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"有符号数和无符号数 ","date":"2020-05-30","objectID":"/argorithm/bit/:2:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"有符号数 有符号数的定义是：字节的最高位作为符号位，其余的是数值位。例如一个字节中存储的二进制数为1100 1000，最高位1作为符号位，其余的7为 100 1000 作为数值为。 那么，符号位占据1位，就有0和1这样的两种数值，就有： 如果符号位为0，那么字节中存储的数值是正数 如果符号位为1，那么字节中存储的数值是负数 对于1100 1000这样的二进制数据，符号位是1，就表示负数。 在有符号数中，表示负数的算法是： 把数值位中存储的二进制数据，每个位都取反，就是原来为0的值变为1，原来为1的值变为0； 给对取反后的二进制数据加1，得到的数值就得到负数值； ","date":"2020-05-30","objectID":"/argorithm/bit/:2:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"无符号数 无符号数的定义是：没有符号位，所有的位数都是数值位。所以表示的都是正数。 ","date":"2020-05-30","objectID":"/argorithm/bit/:2:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"例子 例一 1100 1000这个数值，如果作为有符号数看待，那么符号位是1，数值位是100 1000。所以，符号位是1，所以，这个数据是负数。然后，表示成十进制时，对数值位的操作是： 数值位取反，得到011 0111； 对取反后的数值 011 0111加1得到011 1000，数值位的值为56； 那么，1100 1000这个二进制数据表示为“有符号数”时，就是-56这个数值。 如果作为无符号数看待，那么，就没有符号位，所有的位数都是数值位，所以11001000都作为数值位，表示的十进制数值是200 例二 例如，0111 0011这个数值，如果当做“有符号数”看待，那么，其符号位是0，所以，表示整数，数值位是115，所以，表示正115这个数值。如果当做无符号数看待，所有位都是数值位，计算得到115这个数值，所以，表示正115。所以我们可以总结 ","date":"2020-05-30","objectID":"/argorithm/bit/:2:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"总结 无符号数，总是表示正数。所有位数都表示数值位。 有符号数，可以表示正数和负数，最高位是符号位，其余位都是数值位。如果符号位是0，则表示正数；如果符号位是1，则表示负数。对于负数的表示方法是：数值位全部取反，再加1，得到的数值就是负数值。 ","date":"2020-05-30","objectID":"/argorithm/bit/:2:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"原码、反码、补码 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"原码 原码的表示范围-127~-0, +0~+127, 共256个数字 正0的原码是0000 0000, 负0的原码是1000 0000, 有正0负0之分, 不符合人的习惯, 待解决. 原码有几个缺点，零分两种 +0 和 -0 。还有，在进行不同符号的加法运算或者同符号的减法运算的时候，不能直接判断出结果的正负。你需要将两个值的绝对值进行比较，然后进行加减操作 ，最后符号位由绝对值大的决定。于是反码就产生了。 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"反码 除符号位, 原码其余位取反而得 +0：0000 0000，-0：1111 1111 仍然有正0负0之分。 正数的反码就是原码，负数的反码等于原码除符号位以外所有的位取反 举例说明： int类型的 3 的反码是 00000000 00000000 00000000 00000011 和原码一样没什么可说的 int类型的 -3 的反码是 11111111 11111111 11111111 11111100 除开符号位 所有位 取反 解决了加减运算的问题，但还是有正负零之分，然后就到补码了 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"补码 在反码的基础上加1而得 对原码的两种0同时末位加1 +0：0000 0000，-0：0000 0000(因为溢出导致8位全0) 消除了正0负0之别, 如此一来, 便节省出一个数值表示方式1000 0000, 不能浪费, 用来表示-128, -128特殊之处在于没有相应的反码原码。也可以这样考虑: -1： 1111 1111 -2： 1111 1110（在-1的基础上减1，直接将补码减1即可） -3： 1111 1101（在-2补码基础上减1，以下类似） -4： 1111 1100 …… -127：1000 0001 -128：1000 0000 如此以来：8位补码表示范围是-128~+127因为0只有一种形式所以，仍然是256个数 若8位代表无符号数, 则表示范围是 : 0~255, 这就是为什么高级语言讲到数据类型， 正数的补码与原码相同，负数的补码为 其原码除符号位外所有位取反（得到反码了），然后最低位加1 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"原码，反码，补码总结 正数的反码和补码都与原码相同。 负数的反码为对该数的原码除符号位外各位取反。 负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1　 优缺点: 原码最好理解了，但是加减法不够方便，还有两个零。。 反码稍微困难一些，解决了加减法的问题，但还是有有个零 补码理解困难，其他就没什么缺点了 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"存储 计算机中的整数是用补码存储的，最高位为符号位 如果最高位为0则为正数，求值的时候，直接转为10进制即可。 最高位如果为1代表为负数，求值的时候，需要先把二进制的值按位取反，然后加1得到负数绝对值(相反数)的二进制码，然后转为10进制，加上负号即可。 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"原码，反码，补码的应用 ","date":"2020-05-30","objectID":"/argorithm/bit/:3:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"负数的十进制和二进制转换 ","date":"2020-05-30","objectID":"/argorithm/bit/:4:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"十进制转二进制 方法为: 先转换为二进制 对二进制数求反 再将该二进制数加一 总而言之: 十进制数转换为二进制数求补码即为结果 例子 -32 转换为二进制 第一步：32（10）=00100000（2） 第二步：求反：11011111 第三步：加1:11100000 所以-32（10）=11100000（2） ","date":"2020-05-30","objectID":"/argorithm/bit/:4:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"二进制转十进制 方法为: 数值为取反 对该二进制加一 转换为10进制 例子 11001000 转换为十进制 第一步（数值位取反）： 10110111 第二步（加一）：10111000 第三步（十进制）：-56 所以11001000（2）=-56（10） ","date":"2020-05-30","objectID":"/argorithm/bit/:4:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"十进制数求反的规律 下面都是以10进制表示: ","date":"2020-05-30","objectID":"/argorithm/bit/:5:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"负数求反 负数求反等于其绝对值 -1 如: num = -5 num1 = ~num # 4 ","date":"2020-05-30","objectID":"/argorithm/bit/:5:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"正数求反 正数求反等于其值 +1 的负数 如: num = 4 num1 = ~num # -5 ","date":"2020-05-30","objectID":"/argorithm/bit/:5:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"二进制的应用场景 ","date":"2020-05-30","objectID":"/argorithm/bit/:6:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作实现乘除法 数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2 a = 2 a \u003e\u003e 1 # ---\u003e 1 a \u003c\u003c 1 # ---\u003e 4 ","date":"2020-05-30","objectID":"/argorithm/bit/:6:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作交换两数 位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高 # 普通操作 def swap(a: int, b: int) -\u003e(int,int): a = a + b b = a - b a = a - b return a,b # 位与操作 def swap(a: int, b: int) -\u003e (int, int): \"\"\" 交换两个数 :param a: :param b: :return: \"\"\" a ^= b # a = (a^b) b ^= a # b = b ^ a = b ^ a ^ b a ^= b # a = a ^ b = a ^ a ^ b return a, b ","date":"2020-05-30","objectID":"/argorithm/bit/:6:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作判断奇偶数 只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数 if(0 == (a \u0026 1)) { //偶数 } ","date":"2020-05-30","objectID":"/argorithm/bit/:6:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作交换符号 交换符号将正数变成负数，负数变成正数 func reversal(a int) int { return ^a + 1 } def reversal(a: int) -\u003e int: \"\"\" 求相反数 :param a: :return: \"\"\" return ~a + 1 正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数 ","date":"2020-05-30","objectID":"/argorithm/bit/:6:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作求绝对值 正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作 def abs(a: int) -\u003e int: i = a \u003e\u003e 31 result = a if i == 0 else ~a + 1 return result 上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1) def abs(a: int) -\u003e int: \"\"\" 求绝对值 :param a: :return: \"\"\" i = a \u003e\u003e 31 result = (a ^ i) - i return result or func abs(a int) int { i := a \u003e\u003e 31 return (a ^ i) - i } ","date":"2020-05-30","objectID":"/argorithm/bit/:6:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作进行高低位交换 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如 从上面移位操作我们可以知道，只要将无符号数 a»8 即可得到其高 8 位移到低 8 位，高位补 0；将 a « 8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a » 8 和 a«8 进行或操作既可求得交换后的结果 。 unsigned short a = 34520; a = (a \u003e\u003e 8) | (a \u003c\u003c 8); ","date":"2020-05-30","objectID":"/argorithm/bit/:6:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位操作统计二进制中 1 的个数 统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。 这里介绍另外一种高效的方法，同样以 34520 为例， 我们计算其 a \u0026= (a-1)的结果： 第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000 第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000 第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，每计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：count = 0 def count_1(a: int) -\u003e int: \"\"\" 计算数值的二进制表示的1的数量 :param a: :return: \"\"\" count = 0 while (a): a = a \u0026 a - 1 count += 1 return count ","date":"2020-05-30","objectID":"/argorithm/bit/:6:7","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"求和 两数求和 func add(a int, b int) int { for b != 0 { sum := a ^ b carry := (a \u0026 b) \u003c\u003c 1 a = sum b = carry } return a } ","date":"2020-05-30","objectID":"/argorithm/bit/:6:8","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"比特位计数 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] def countBits(num: int) -\u003e [int]: result = [0] * (num + 1) for i in range(1, num + 1): result[i] = result[i \u0026 i - 1] + 1 return result func countBits(num int) []int { result := make([]int, num+1) for i := 1; i \u003c num+1 ; i ++ { result[i] = result[i \u0026 (i-1)] + 1 } return result } ","date":"2020-05-30","objectID":"/argorithm/bit/:6:9","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"常用的特殊的数 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0） 0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1） 0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现) 0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现) 0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现) 0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现) 0xffffffff = 11111111111111111111111111111111 ","date":"2020-05-30","objectID":"/argorithm/bit/:7:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/argorithm/bit/"},{"categories":null,"content":"位运算合集","date":"2020-05-30","objectID":"/bit/","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位运算 计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。 ","date":"2020-05-30","objectID":"/bit/:0:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作符 ","date":"2020-05-30","objectID":"/bit/:1:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"\u0026 与运算 \u0026 与运算 两个位都是 1 时，结果才为 1，否则为 0，如 1 0 0 1 1 \u0026 1 1 0 0 1 ------------------------------ 1 0 0 0 1 ","date":"2020-05-30","objectID":"/bit/:1:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如 1 0 0 1 1 | 1 1 0 0 1 ------------------------------ 1 1 0 1 1 ","date":"2020-05-30","objectID":"/bit/:1:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"^ 异或运算 两个位相同则为 0，不同则为 1，如 1 0 0 1 1 ^ 1 1 0 0 1 ----------------------------- 0 1 0 1 0 ","date":"2020-05-30","objectID":"/bit/:1:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"~ 取反运算 0 则变为 1，1 则变为 0，如 ~ 1 0 0 1 1 ----------------------------- 0 1 1 0 0 ","date":"2020-05-30","objectID":"/bit/:1:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"« 左移运算 向左进行移位操作，高位丢弃，低位补 0,如 int a = 8; a \u003c\u003c 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0100 0000 左移n为的值即为当前值*2^n, 如: a = 8 b = a\u003c\u003c3 # 64 c = a * (2 ** 3) # 64 ","date":"2020-05-30","objectID":"/bit/:1:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"»右移运算 向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如 unsigned int a = 8; a \u003e\u003e 3; 移位前：0000 0000 0000 0000 0000 0000 0000 1000 移位后：0000 0000 0000 0000 0000 0000 0000 0001 ​ int a = -8; a \u003e\u003e 3; 移位前：1111 1111 1111 1111 1111 1111 1111 1000 移位前：1111 1111 1111 1111 1111 1111 1111 1111 ","date":"2020-05-30","objectID":"/bit/:1:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"有符号数和无符号数 ","date":"2020-05-30","objectID":"/bit/:2:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"有符号数 有符号数的定义是：字节的最高位作为符号位，其余的是数值位。例如一个字节中存储的二进制数为1100 1000，最高位1作为符号位，其余的7为 100 1000 作为数值为。 那么，符号位占据1位，就有0和1这样的两种数值，就有： 如果符号位为0，那么字节中存储的数值是正数 如果符号位为1，那么字节中存储的数值是负数 对于1100 1000这样的二进制数据，符号位是1，就表示负数。 在有符号数中，表示负数的算法是： 把数值位中存储的二进制数据，每个位都取反，就是原来为0的值变为1，原来为1的值变为0； 给对取反后的二进制数据加1，得到的数值就得到负数值； ","date":"2020-05-30","objectID":"/bit/:2:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"无符号数 无符号数的定义是：没有符号位，所有的位数都是数值位。所以表示的都是正数。 ","date":"2020-05-30","objectID":"/bit/:2:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"例子 例一 1100 1000这个数值，如果作为有符号数看待，那么符号位是1，数值位是100 1000。所以，符号位是1，所以，这个数据是负数。然后，表示成十进制时，对数值位的操作是： 数值位取反，得到011 0111； 对取反后的数值 011 0111加1得到011 1000，数值位的值为56； 那么，1100 1000这个二进制数据表示为“有符号数”时，就是-56这个数值。 如果作为无符号数看待，那么，就没有符号位，所有的位数都是数值位，所以11001000都作为数值位，表示的十进制数值是200 例二 例如，0111 0011这个数值，如果当做“有符号数”看待，那么，其符号位是0，所以，表示整数，数值位是115，所以，表示正115这个数值。如果当做无符号数看待，所有位都是数值位，计算得到115这个数值，所以，表示正115。所以我们可以总结 ","date":"2020-05-30","objectID":"/bit/:2:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"总结 无符号数，总是表示正数。所有位数都表示数值位。 有符号数，可以表示正数和负数，最高位是符号位，其余位都是数值位。如果符号位是0，则表示正数；如果符号位是1，则表示负数。对于负数的表示方法是：数值位全部取反，再加1，得到的数值就是负数值。 ","date":"2020-05-30","objectID":"/bit/:2:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"原码、反码、补码 ","date":"2020-05-30","objectID":"/bit/:3:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"原码 原码的表示范围-127~-0, +0~+127, 共256个数字 正0的原码是0000 0000, 负0的原码是1000 0000, 有正0负0之分, 不符合人的习惯, 待解决. 原码有几个缺点，零分两种 +0 和 -0 。还有，在进行不同符号的加法运算或者同符号的减法运算的时候，不能直接判断出结果的正负。你需要将两个值的绝对值进行比较，然后进行加减操作 ，最后符号位由绝对值大的决定。于是反码就产生了。 ","date":"2020-05-30","objectID":"/bit/:3:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"反码 除符号位, 原码其余位取反而得 +0：0000 0000，-0：1111 1111 仍然有正0负0之分。 正数的反码就是原码，负数的反码等于原码除符号位以外所有的位取反 举例说明： int类型的 3 的反码是 00000000 00000000 00000000 00000011 和原码一样没什么可说的 int类型的 -3 的反码是 11111111 11111111 11111111 11111100 除开符号位 所有位 取反 解决了加减运算的问题，但还是有正负零之分，然后就到补码了 ","date":"2020-05-30","objectID":"/bit/:3:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"补码 在反码的基础上加1而得 对原码的两种0同时末位加1 +0：0000 0000，-0：0000 0000(因为溢出导致8位全0) 消除了正0负0之别, 如此一来, 便节省出一个数值表示方式1000 0000, 不能浪费, 用来表示-128, -128特殊之处在于没有相应的反码原码。也可以这样考虑: -1： 1111 1111 -2： 1111 1110（在-1的基础上减1，直接将补码减1即可） -3： 1111 1101（在-2补码基础上减1，以下类似） -4： 1111 1100 …… -127：1000 0001 -128：1000 0000 如此以来：8位补码表示范围是-128~+127因为0只有一种形式所以，仍然是256个数 若8位代表无符号数, 则表示范围是 : 0~255, 这就是为什么高级语言讲到数据类型， 正数的补码与原码相同，负数的补码为 其原码除符号位外所有位取反（得到反码了），然后最低位加1 ","date":"2020-05-30","objectID":"/bit/:3:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"原码，反码，补码总结 正数的反码和补码都与原码相同。 负数的反码为对该数的原码除符号位外各位取反。 负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1　 优缺点: 原码最好理解了，但是加减法不够方便，还有两个零。。 反码稍微困难一些，解决了加减法的问题，但还是有有个零 补码理解困难，其他就没什么缺点了 ","date":"2020-05-30","objectID":"/bit/:3:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"存储 计算机中的整数是用补码存储的，最高位为符号位 如果最高位为0则为正数，求值的时候，直接转为10进制即可。 最高位如果为1代表为负数，求值的时候，需要先把二进制的值按位取反，然后加1得到负数绝对值(相反数)的二进制码，然后转为10进制，加上负号即可。 ","date":"2020-05-30","objectID":"/bit/:3:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"原码，反码，补码的应用 ","date":"2020-05-30","objectID":"/bit/:3:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"负数的十进制和二进制转换 ","date":"2020-05-30","objectID":"/bit/:4:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"十进制转二进制 方法为: 先转换为二进制 对二进制数求反 再将该二进制数加一 总而言之: 十进制数转换为二进制数求补码即为结果 例子 -32 转换为二进制 第一步：32（10）=00100000（2） 第二步：求反：11011111 第三步：加1:11100000 所以-32（10）=11100000（2） ","date":"2020-05-30","objectID":"/bit/:4:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"二进制转十进制 方法为: 数值为取反 对该二进制加一 转换为10进制 例子 11001000 转换为十进制 第一步（数值位取反）： 10110111 第二步（加一）：10111000 第三步（十进制）：-56 所以11001000（2）=-56（10） ","date":"2020-05-30","objectID":"/bit/:4:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"十进制数求反的规律 下面都是以10进制表示: ","date":"2020-05-30","objectID":"/bit/:5:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"负数求反 负数求反等于其绝对值 -1 如: num = -5 num1 = ~num # 4 ","date":"2020-05-30","objectID":"/bit/:5:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"正数求反 正数求反等于其值 +1 的负数 如: num = 4 num1 = ~num # -5 ","date":"2020-05-30","objectID":"/bit/:5:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"二进制的应用场景 ","date":"2020-05-30","objectID":"/bit/:6:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作实现乘除法 数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2 a = 2 a \u003e\u003e 1 # ---\u003e 1 a \u003c\u003c 1 # ---\u003e 4 ","date":"2020-05-30","objectID":"/bit/:6:1","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作交换两数 位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高 # 普通操作 def swap(a: int, b: int) -\u003e(int,int): a = a + b b = a - b a = a - b return a,b # 位与操作 def swap(a: int, b: int) -\u003e (int, int): \"\"\" 交换两个数 :param a: :param b: :return: \"\"\" a ^= b # a = (a^b) b ^= a # b = b ^ a = b ^ a ^ b a ^= b # a = a ^ b = a ^ a ^ b return a, b ","date":"2020-05-30","objectID":"/bit/:6:2","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作判断奇偶数 只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数 if(0 == (a \u0026 1)) { //偶数 } ","date":"2020-05-30","objectID":"/bit/:6:3","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作交换符号 交换符号将正数变成负数，负数变成正数 func reversal(a int) int { return ^a + 1 } def reversal(a: int) -\u003e int: \"\"\" 求相反数 :param a: :return: \"\"\" return ~a + 1 正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数 ","date":"2020-05-30","objectID":"/bit/:6:4","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作求绝对值 正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作 def abs(a: int) -\u003e int: i = a \u003e\u003e 31 result = a if i == 0 else ~a + 1 return result 上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1) def abs(a: int) -\u003e int: \"\"\" 求绝对值 :param a: :return: \"\"\" i = a \u003e\u003e 31 result = (a ^ i) - i return result or func abs(a int) int { i := a \u003e\u003e 31 return (a ^ i) - i } ","date":"2020-05-30","objectID":"/bit/:6:5","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作进行高低位交换 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如 从上面移位操作我们可以知道，只要将无符号数 a»8 即可得到其高 8 位移到低 8 位，高位补 0；将 a « 8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a » 8 和 a«8 进行或操作既可求得交换后的结果 。 unsigned short a = 34520; a = (a \u003e\u003e 8) | (a \u003c\u003c 8); ","date":"2020-05-30","objectID":"/bit/:6:6","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"位操作统计二进制中 1 的个数 统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。 这里介绍另外一种高效的方法，同样以 34520 为例， 我们计算其 a \u0026= (a-1)的结果： 第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000 第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000 第三次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，每计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：count = 0 def count_1(a: int) -\u003e int: \"\"\" 计算数值的二进制表示的1的数量 :param a: :return: \"\"\" count = 0 while (a): a = a \u0026 a - 1 count += 1 return count ","date":"2020-05-30","objectID":"/bit/:6:7","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"求和 两数求和 func add(a int, b int) int { for b != 0 { sum := a ^ b carry := (a \u0026 b) \u003c\u003c 1 a = sum b = carry } return a } ","date":"2020-05-30","objectID":"/bit/:6:8","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"比特位计数 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] def countBits(num: int) -\u003e [int]: result = [0] * (num + 1) for i in range(1, num + 1): result[i] = result[i \u0026 i - 1] + 1 return result func countBits(num int) []int { result := make([]int, num+1) for i := 1; i \u003c num+1 ; i ++ { result[i] = result[i \u0026 (i-1)] + 1 } return result } ","date":"2020-05-30","objectID":"/bit/:6:9","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"常用的特殊的数 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0） 0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1） 0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现) 0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现) 0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现) 0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现) 0xffffffff = 11111111111111111111111111111111 ","date":"2020-05-30","objectID":"/bit/:7:0","tags":["算法","位运算","bit"],"title":"位运算","uri":"/bit/"},{"categories":null,"content":"二叉搜索树","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"定义及特点 二叉查找树（英语：Binary Search Tree），也称为 二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。 二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 O(\\log n)O(logn)，最坏 O(n)O(n)（数列有序，树退化成线性表）。 虽然二叉查找树的最坏效率是 O(n)O(n)，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为 O(\\log n)O(logn)，从而将最坏效率降至 O(\\log n)O(logn)，如 AVL 树、红黑树等。 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:1:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"常用操作 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"树节点定义: class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None or type TreeNode struct { Val int Left *TreeNode Right *TreeNode } ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:1","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"查找 在二叉搜索树b中查找x的过程为： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则递归搜索左子树；否则: 递归查找右子树 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:2","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"插入 向一个二叉搜索树b中插入一个节点s的算法，过程为： 若b是空树，则将s所指结点作为根节点插入，否则： 若s.val等于b的根节点的数据域之值，则返回，否则： 若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则： 把s所指节点插入到右子树中（新插入节点总是叶子节点） ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:3","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"删除 二叉搜索树的删除操作分三种情况讨论: 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： 例：删除数据为16的节点，是叶子节点，可以直接删除 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之 例：删除数据为25的节点，它下面有唯一一个子节点35, 上移到替换之 如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示 例：删除节点数据为5的节点，找到被删除节点右子树的最小节点。需要一个临时变量successor，将11节点下面的子节点进行查询，找到右子树最小节点7，并把右子树最小节点7替换被删除节点，维持二叉树结构。如下图 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:4","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"遍历 可以采用前序，中序，后序来遍历该二叉搜索树，或者使用广度优先搜索的方式。这里用中序遍历来实现，可以保证按从小到大的顺序打印。 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:5","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"构造一颗二叉查找树 用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为 O(n2)。例如，若该组数值经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树 ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:2:6","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"常用操作的实现 python版 # 节点定义 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # 查找 def search(root: TreeNode, val: int) -\u003e (bool, TreeNode): if root == None: return False, None elif val \u003e root.val: return search(root.right, val) elif val \u003c root.val: return search(root.left, val) else: return True, root # 插入 def insert(root: TreeNode, node: TreeNode) -\u003e TreeNode: \"\"\"insert inplace\"\"\" if root == None: root = node return root elif node.val \u003e root.val: root.right = insert(root.right, node) else: root.left = insert(root.left, node) return root # 删除 def deleteNode(root: TreeNode, key: int) -\u003e TreeNode: \"\"\" :type root: TreeNode :type key: int :rtype: TreeNode \"\"\" if root == None: return None if key \u003c root.val: root.left = deleteNode(root.left, key) elif key \u003e root.val: root.right = deleteNode(root.right, key) else: if root.left == None: return root.right elif root.right == None: return root.left else: min_node = findMinNode(root.right) root.val = min_node.val root.right = deleteNode(root.right, root.val) return root def findMinNode(node: TreeNode) -\u003e TreeNode: while node.left: node = node.left return node # 中序遍历 def traverse_binary_tree(root: TreeNode): if root is None: return traverse_binary_tree(root.left) print(root.val) traverse_binary_tree(root.right) # 构建二叉树 def build_binary_tree(values: [int]): tree = None for v in values: tree = insert(tree, TreeNode(v)) return tree if __name__ == \"__main__\": values = [17, 5, 35, 2, 11, 29, 38, 9, 16, 7] # 构造二叉树 node = build_binary_tree(values) # 查找 node_7 = search(node, 35) # 遍历 traverse_binary_tree(node) # 删除 a = deleteNode(node, 5) print() golang版: package main import \"fmt\" type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { values := []int{17, 5, 35, 2, 11, 29, 38, 9, 16, 7} // 测试构造二叉树 node := buildBinarySearchTree(values) // 遍历 traverseBinarySearchTree(node) // 搜索 ok, child := search(node, 11) // 删除 new_node := deleteTreenode(node, 35) fmt.Println(new_node) fmt.Println(ok, child) } // 查找 func search(root *TreeNode, val int) (bool, *TreeNode) { if root == nil { return false, nil } if root.Val == val { return true, root } else if root.Val \u003c val { return search(root.Right, val) } else { return search(root.Left, val) } } // 插入 func insert(root, node *TreeNode) *TreeNode { if root == nil { root = node return root } if root.Val \u003e node.Val { root.Left = insert(root.Left, node) } else { root.Right = insert(root.Right, node) } return root } // 删除 func deleteTreenode(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val \u003e val { root.Left = deleteTreenode(root.Left, val) } else if root.Val \u003c val { root.Right = deleteTreenode(root.Right, val) } else { if root.Left == nil { return root.Right } else if root.Right == nil { return root.Left } else { min_node := findMinNode(root.Right) root.Val = min_node.Val root.Right = deleteTreenode(root.Right, min_node.Val) } } return root } func findMinNode(root *TreeNode) *TreeNode { for root.Left != nil { root = root.Left } return root } // 中序遍历 func traverseBinarySearchTree(root *TreeNode) { if root == nil { return } traverseBinarySearchTree(root.Left) fmt.Println(root.Val) traverseBinarySearchTree(root.Right) } // 构建二叉搜索树 func buildBinarySearchTree(values []int) *TreeNode { var node *TreeNode = nil for _, value := range values { node = insert(node, \u0026TreeNode{Val: value}) } return node } ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:3:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"性能分析 查找：最佳情况Olog(n), 最坏情况O(n) 插入：最佳情况Olog(n), 最坏情况O(n) 删除：最佳情况Olog(n), 最坏情况O(n) ","date":"2020-05-05","objectID":"/argorithm/binarysearchtree/:4:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/argorithm/binarysearchtree/"},{"categories":null,"content":"二叉搜索树","date":"2020-05-05","objectID":"/binarysearchtree/","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"定义及特点 二叉查找树（英语：Binary Search Tree），也称为 二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。 二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 O(\\log n)O(logn)，最坏 O(n)O(n)（数列有序，树退化成线性表）。 虽然二叉查找树的最坏效率是 O(n)O(n)，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为 O(\\log n)O(logn)，从而将最坏效率降至 O(\\log n)O(logn)，如 AVL 树、红黑树等。 ","date":"2020-05-05","objectID":"/binarysearchtree/:1:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"常用操作 ","date":"2020-05-05","objectID":"/binarysearchtree/:2:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"树节点定义: class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None or type TreeNode struct { Val int Left *TreeNode Right *TreeNode } ","date":"2020-05-05","objectID":"/binarysearchtree/:2:1","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"查找 在二叉搜索树b中查找x的过程为： 若b是空树，则搜索失败，否则： 若x等于b的根节点的数据域之值，则查找成功；否则： 若x小于b的根节点的数据域之值，则递归搜索左子树；否则: 递归查找右子树 ","date":"2020-05-05","objectID":"/binarysearchtree/:2:2","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"插入 向一个二叉搜索树b中插入一个节点s的算法，过程为： 若b是空树，则将s所指结点作为根节点插入，否则： 若s.val等于b的根节点的数据域之值，则返回，否则： 若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则： 把s所指节点插入到右子树中（新插入节点总是叶子节点） ","date":"2020-05-05","objectID":"/binarysearchtree/:2:3","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"删除 二叉搜索树的删除操作分三种情况讨论: 如果待删除的节点是叶子节点，那么可以立即被删除，如下图所示： 例：删除数据为16的节点，是叶子节点，可以直接删除 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之 例：删除数据为25的节点，它下面有唯一一个子节点35, 上移到替换之 如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除，如下图所示 例：删除节点数据为5的节点，找到被删除节点右子树的最小节点。需要一个临时变量successor，将11节点下面的子节点进行查询，找到右子树最小节点7，并把右子树最小节点7替换被删除节点，维持二叉树结构。如下图 ","date":"2020-05-05","objectID":"/binarysearchtree/:2:4","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"遍历 可以采用前序，中序，后序来遍历该二叉搜索树，或者使用广度优先搜索的方式。这里用中序遍历来实现，可以保证按从小到大的顺序打印。 ","date":"2020-05-05","objectID":"/binarysearchtree/:2:5","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"构造一颗二叉查找树 用一组数值建造一棵二叉查找树的同时，也把这组数值进行了排序。其最差时间复杂度为 O(n2)。例如，若该组数值经是有序的（从小到大），则建造出来的二叉查找树的所有节点，都没有左子树 ","date":"2020-05-05","objectID":"/binarysearchtree/:2:6","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"常用操作的实现 python版 # 节点定义 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # 查找 def search(root: TreeNode, val: int) -\u003e (bool, TreeNode): if root == None: return False, None elif val \u003e root.val: return search(root.right, val) elif val \u003c root.val: return search(root.left, val) else: return True, root # 插入 def insert(root: TreeNode, node: TreeNode) -\u003e TreeNode: \"\"\"insert inplace\"\"\" if root == None: root = node return root elif node.val \u003e root.val: root.right = insert(root.right, node) else: root.left = insert(root.left, node) return root # 删除 def deleteNode(root: TreeNode, key: int) -\u003e TreeNode: \"\"\" :type root: TreeNode :type key: int :rtype: TreeNode \"\"\" if root == None: return None if key \u003c root.val: root.left = deleteNode(root.left, key) elif key \u003e root.val: root.right = deleteNode(root.right, key) else: if root.left == None: return root.right elif root.right == None: return root.left else: min_node = findMinNode(root.right) root.val = min_node.val root.right = deleteNode(root.right, root.val) return root def findMinNode(node: TreeNode) -\u003e TreeNode: while node.left: node = node.left return node # 中序遍历 def traverse_binary_tree(root: TreeNode): if root is None: return traverse_binary_tree(root.left) print(root.val) traverse_binary_tree(root.right) # 构建二叉树 def build_binary_tree(values: [int]): tree = None for v in values: tree = insert(tree, TreeNode(v)) return tree if __name__ == \"__main__\": values = [17, 5, 35, 2, 11, 29, 38, 9, 16, 7] # 构造二叉树 node = build_binary_tree(values) # 查找 node_7 = search(node, 35) # 遍历 traverse_binary_tree(node) # 删除 a = deleteNode(node, 5) print() golang版: package main import \"fmt\" type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func main() { values := []int{17, 5, 35, 2, 11, 29, 38, 9, 16, 7} // 测试构造二叉树 node := buildBinarySearchTree(values) // 遍历 traverseBinarySearchTree(node) // 搜索 ok, child := search(node, 11) // 删除 new_node := deleteTreenode(node, 35) fmt.Println(new_node) fmt.Println(ok, child) } // 查找 func search(root *TreeNode, val int) (bool, *TreeNode) { if root == nil { return false, nil } if root.Val == val { return true, root } else if root.Val \u003c val { return search(root.Right, val) } else { return search(root.Left, val) } } // 插入 func insert(root, node *TreeNode) *TreeNode { if root == nil { root = node return root } if root.Val \u003e node.Val { root.Left = insert(root.Left, node) } else { root.Right = insert(root.Right, node) } return root } // 删除 func deleteTreenode(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val \u003e val { root.Left = deleteTreenode(root.Left, val) } else if root.Val \u003c val { root.Right = deleteTreenode(root.Right, val) } else { if root.Left == nil { return root.Right } else if root.Right == nil { return root.Left } else { min_node := findMinNode(root.Right) root.Val = min_node.Val root.Right = deleteTreenode(root.Right, min_node.Val) } } return root } func findMinNode(root *TreeNode) *TreeNode { for root.Left != nil { root = root.Left } return root } // 中序遍历 func traverseBinarySearchTree(root *TreeNode) { if root == nil { return } traverseBinarySearchTree(root.Left) fmt.Println(root.Val) traverseBinarySearchTree(root.Right) } // 构建二叉搜索树 func buildBinarySearchTree(values []int) *TreeNode { var node *TreeNode = nil for _, value := range values { node = insert(node, \u0026TreeNode{Val: value}) } return node } ","date":"2020-05-05","objectID":"/binarysearchtree/:3:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"性能分析 查找：最佳情况Olog(n), 最坏情况O(n) 插入：最佳情况Olog(n), 最坏情况O(n) 删除：最佳情况Olog(n), 最坏情况O(n) ","date":"2020-05-05","objectID":"/binarysearchtree/:4:0","tags":["算法","binarySearchTree","二叉搜索树"],"title":"二叉搜索树","uri":"/binarysearchtree/"},{"categories":null,"content":"How to run jenkins on kubernetes","date":"2020-02-08","objectID":"/opensrouce/k8s_jenkins/","tags":["kubernetes","jenkins"],"title":"How to run jenkins on kubernetes","uri":"/opensrouce/k8s_jenkins/"},{"categories":null,"content":"作用 如何在Kubernetes环境中运行jenkins ","date":"2020-02-08","objectID":"/opensrouce/k8s_jenkins/:1:0","tags":["kubernetes","jenkins"],"title":"How to run jenkins on kubernetes","uri":"/opensrouce/k8s_jenkins/"},{"categories":null,"content":"项目地址 https://github.com/russellgao/k8s_jenkins ","date":"2020-02-08","objectID":"/opensrouce/k8s_jenkins/:2:0","tags":["kubernetes","jenkins"],"title":"How to run jenkins on kubernetes","uri":"/opensrouce/k8s_jenkins/"},{"categories":null,"content":"参考 https://mp.weixin.qq.com/s/7YFlmcUH5iOB2XOBIZ2_rA ","date":"2020-02-08","objectID":"/opensrouce/k8s_jenkins/:3:0","tags":["kubernetes","jenkins"],"title":"How to run jenkins on kubernetes","uri":"/opensrouce/k8s_jenkins/"},{"categories":null,"content":"在k8s 中运行EKL","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"},{"categories":null,"content":"作用 如何在Kubernetes环境中运行ELK Stack ","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/:1:0","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"},{"categories":null,"content":"项目地址 https://github.com/russellgao/k8s_elk ","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/:2:0","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"},{"categories":null,"content":"用法 manifests Can run in production environment experimental In the experimental stage 使用之前需要修改各个yaml文件的Storage，Service相关的参数，根据实际情况选择合适的介质，修改完之后执行kubectl -f manifests 即可。 详细信息参考 github ","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/:3:0","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"},{"categories":null,"content":"支持的组件 es logstash kibana kafka zookeeper ","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/:4:0","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"},{"categories":null,"content":"More https://mp.weixin.qq.com/s/93_Jf8P69Q0nkw1Ip7MsFQ ","date":"2020-01-04","objectID":"/opensrouce/k8s_elk/:5:0","tags":["kubernetes","ELK"],"title":"ELK stack on kubernetes","uri":"/opensrouce/k8s_elk/"}]